<html>
<head>
  <style>
    body, canvas, p { background: black; color: #0f0; padding:0; border:0; margin:0; height=100%; width=100%; }
    .off { display:none; }
  </style>
</head>

<body id="pcanvas">
  <canvas id="mycanvas"></canvas>
  <p id="DB" style="position:fixed; right:0; bottom:0; width:20em; max-height:20em; background:#0f01; overflow:auto; white-space:pre"></p>
</body><script>
"use strict";

var stars=document.createElement("img");
stars.src="stars.jpg";
var starsr=document.createElement("img");
starsr.src="starsr.jpg";



/******************************************************************************
  Debug message console and error checking

  DOM requirements::
    <p id="DB"></p>        -- If nonexistent, the DB object will revert to using the browser's console.

  Usage::
    DB("string")           -- Send string to info window.  Behaves like a pre element.
    DB.log("string")       -- Send string to console.log.
    DB.post(type, string)  -- Send string to info window band keeps track of type.  Subsequent typed messages replace the last.
    DB.post(type, string)  -- Send string to info window band keeps track of type.  Subsequent typed messages replace the last.
    DB.clear()             -- Empty the entire DB element.
    DB.check(expr, string) -- If expr is false, send string to console.  status() will then always return false.
    DB.status()            -- Returns false if check ever failed.
******************************************************************************/
var DB = (function () {
  var consoleElement = document.getElementById('DB');
  var self;
  var status = true;
  var shouldNewline = true; // Want to prepend a newline when the last message was plain text.
  var lastPostType = false, lastPost = false;
  var repeatCount = 0;

  var setStyles = function (e) {
    //e.style.border = "solid 1px green";
    //e.style.whiteSpace = "pre";
    //e.style.overflow = "auto";
    //e.style.maxHeight = "20em";
  }

  // Create the instance which is a function.  Also create the clear function.
  if (!consoleElement) {
    self = function (s) { console.log(s); lastPostType = false;}
    self.log = self;
    self.post  = function (t, s) { // For the console, only the first post type is displayed.
      if (t != lastPostType) {
        console.log("[" + t + "]" + s);
        lastPostType = t;
      }
    }
    self.clear = function () { lastPostType = false; }
  } else {
    //setStyles(consoleElement);
    self = function (s) {
      if (lastPost == s) {
       ++repeatCount;
        s = repeatCount + s;
      } else {
        repeatCount = 0;
      }
      consoleElement.innerHTML += (shouldNewline ? "" : "\n") + s;
      consoleElement.scrollTop = consoleElement.scrollHeight;
      shouldNewline = lastPostType = false;
    }
    self.log = function (s) { console.log(s); }
    self.post = function (t, s) {
      if (t == lastPostType) {
        if (lastPost == s) { ++repeatCount; }
        consoleElement.lastChild.innerText = (0<repeatCount ? repeatCount : "") + "[" + t + "]" + s;
      } else {
        consoleElement.appendChild(document.createElement('p')).innerText = "[" + t + "]" + s;
        consoleElement.scrollTop = consoleElement.scrollHeight;
        lastPostType = t;
        repeatCount = 0;
      }
      lastPost = s;
      shouldNewline = true;
    }
    self.clear = function () {
       consoleElement.innerHTML = "";
      shouldNewline = lastPostType = true;
    }
  }

  self.check = function (expr, msg) {
    status = status && expr;
    return expr || self(msg) && false;
  }

  self.status = function () { return status; }

  return self;
})(); // DB




/***************************************
  Unit_testing_infrastructure
  assert(ex)          return true -or- false when exp is false along with a message to console.log
  TESTCmpAry(a, b)    Verify array a and b match (both in size and content)
  TESTCmpAryAry(a, b) Verify array a and b match including the sub-arrays
***************************************/
function assert (exp) {
  if (exp) {
    return true;
  } else {
    console.log("ERROR!");
    return false;
  }
}

function TESTCmp (a, b) {
  if (typeof a == "number") TESTCmpNumNum(a,b)
  else assert(a == b);
}

function TESTCmpNumNum (a, b) {
  //assert(a.toFixed(6) == b.toFixed(6));
  var n = a.toFixed(6);
  var m = b.toFixed(6);
  if (n == "-0.000000") n = "0.000000";
  if (m == "-0.000000") m = "0.000000";
  assert(n == m);
}

function TESTCmpObj (a, b) {
  for (var s in a) TESTCmp(a[s], b[s]);
}

function TESTCmpAry (a, b) {
  var i;
  TESTCmpNumNum(a.length, b.length);
  for (i=0; i<a.length; ++i) TESTCmpNumNum(a[i], b[i]);
}

function TESTCmpAryAry (a, b) {
  var i;
  assert(a.length == b.length);
  for (i=0; i<a.length; ++i) TESTCmpAry(a[i], b[i]);
}



/***************************************
  Global_alises_and_functions
***************************************/
var rnd  = function(n){return Math.floor(Math.random()*n);}
var rndf = function(n){return Math.random()*n;}
var sin = Math.sin;
var cos = Math.cos;
var abs = Math.abs;
var square = function (x) {return x*x;}
var getTime = function () { return (new Date).getTime(); }
var eqpair = function (a, b) {return a.x==b.x && a.y==b.y;}
var setLoc = function (a, b) {a.x=b.x;  a.y=b.y;  a.z=b.z;}

Array.prototype.groupby = function (l) { // Group a vector into length l sub vectors.
  return this.reduce( (r,v,i,a) => (i%l || r.push(a.slice(i,i+l)), r), []);
};

Array.prototype.tomap = function () { // Transmogrify an array into a map.  Used to pretty print an array.
  return this.reduce( (r,v,i) => (r[i]=v, r), {})
}

Object.prototype.stringify = function () {
  return JSON.stringify(this);
}

Array.prototype.dumpMat = function () {
  console.log(this.map(n=>("     "+n.toFixed(2)).slice(-8)).groupby(4).map(JSON.stringify).join('\n').replace(/"/g,'').replace(/,/g,' '));
  return this;
}

// In 3D land, radians are king and used often but I'm used to degrees thus these constants.
var PI0   = 0.00000000000000000
var PI1   = 0.017453292519943295
var PI10  = 0.17453292519943295
var PI45  = 0.7853981633974483
var PI80  = 1.3962634015954636
var PI90  = 1.5707963267948966
var PI135 = 2.356194490192345
var PI180 = 3.141592653589793
var PI225 = 3.9269908169872414
var PI270 = 4.71238898038469
var PI315 = 5.497787143782138
var PI360 = 6.283185307179586

// Keep track and setup pertinent canvas values.
var canvas = document.getElementsByTagName('canvas')[0];
var context = canvas.getContext('2d');
var width = canvas.width = document.body.clientWidth;
var height = canvas.height = document.body.clientHeight;
context.translate(width/2, height/2); // Set canvas's origin to center

function clearContext (width, heigth) { // Erase entire canvas.
  DB.post("clearContext", `${width} ${height}`);
  if (collision) {
    context.fillStyle = "red";
    context.fillRect(-width/2,-height/2,width, height);
  } else if (false) { // BF TODO Disabled as looking up/down doesn't affect "box" background.
    // Solid sky
    context.fillStyle = "#080008";
    context.fillRect(-width/2, -height/2, width, height/2);
    //var offset = 2*1013*pacman.diram/8;
    var offset = 2*1013*(mouseLookX%360)/360.0;
    // Bitmap sky
    context.drawImage(starsr, canvas.width/2 - offset + 3*1013, -stars.height)
    context.drawImage(stars,  canvas.width/2 - offset + 2*1013, -stars.height)
    context.drawImage(starsr, canvas.width/2 - offset + 1013, -stars.height)
    context.drawImage(stars,  canvas.width/2 - offset       , -stars.height)
    context.drawImage(starsr, canvas.width/2 - offset - 1013, -stars.height)
    context.drawImage(stars,  canvas.width/2 - offset - 2*1013, -stars.height)
    context.drawImage(starsr, canvas.width/2 - offset - 3*1013, -stars.height)
    context.drawImage(stars,  canvas.width/2 - offset - 4*1013, -stars.height)
    // Solid ground
    context.fillStyle = "#020";
    context.fillRect(-width/2, 0, width, height);
  } else {
    context.fillStyle = "black";
    context.fillRect(-width/2,-height/2,width, height);
  }
}



/***************************************
  Ticker_class - Keeps track of time for
  linear interpolation.  Returns a value
  between 0 and 1 over time.
***************************************/
function Ticker () {
  this.beg = getTime();
  this.span = 1000;
  this.end = this.beg + this.span;
  this.reset = function (newbeg, newspan) {
    this.beg = newbeg;
    this.span = newspan;
    this.end = this.beg + this.span;
  }
  this.tick = function (time) {
    var p = (time - this.beg) / this.span;
    return (1 < p) ? 1 : p;
  }
}
//** TEST **********************************************************************
(function TESTTicker () {
  var ticker = new Ticker(), p;
  ticker.reset(0, 11);
  p=ticker.tick(0); console.log("tick.tick() = " + p);TESTCmpNumNum(p, 0);
  p=ticker.tick(1); console.log("tick.tick() = " + p);TESTCmpNumNum(p, 0.090909);
  p=ticker.tick(5.5); console.log("tick.tick() = " + p);TESTCmpNumNum(p, 0.5);
  p=ticker.tick(10); console.log("tick.tick() = " + p);TESTCmpNumNum(p, 0.909091);
  p=ticker.tick(11); console.log("tick.tick() = " + p);TESTCmpNumNum(p, 1);
  p=ticker.tick(12); console.log("tick.tick() = " + p);TESTCmpNumNum(p, 1);
  console.log("PASS TESTTicker");
}());
//******************************************************************************



/**************************************************************
 Parameterized object interface thingy.  This to become Actor?
**************************************************************/
function Body (pf, start=getTime()) { // parameterized function
  self = function (time=getTime()) {
    return pf((time - start)/1000.0);
  };
  self.tick = self;
  self.entity = pf.entity;
  return self;
}


function Trajectory (ent, gravity, ang, vel) {
  var xyz = ent.locam // Keep track of the starting location and direction of the entity in question..
  var x = xyz.x;
  var y = xyz.y;
  var z = xyz.z;
  var dir = ent.diram;
  var acc = (gravity / -2.0);
  var vh  = (vel * cos(ang)); // Horizontal
  var vy  = (vh * cos(dir)); // Hor.y
  var vx  = (vh * sin(dir)); // Hor.x
  var vv  = (vel * sin(ang)); // Vertical
  var f = (t) => ({x: x + vx * t,
                   y: y + vy * t,
                   z: z + acc * t * t + vv * t})
  f.entity = ent;
  return f;
}


/***************************************
  Entity_class - Models a position and direction
  with the ability to rotate and walk incrementally.

  Used to represent pacman entities that walk around
  a maze and rotate around corners.  Timeline: locfr --locam--> locbe

  Entities state:  location, orientation.  as cartesian matrix and either another matrix and/or angles of rotation

  Associated with polygroups
***************************************/
function Entity (label, aryam, dir0) {
  this.label = label;

  this.locticker = new Ticker();
  this.locfr = {x:aryam[0], y:aryam[1], z:aryam[2]}; // Initial position, beginning tick range
  this.locam = {x:aryam[0], y:aryam[1], z:aryam[2]}; // Actual location, ticking to locbe
  this.locbe = {x:aryam[0], y:aryam[1], z:aryam[2]}; // Final position, end of tick range
  this.locgo = false;                                // Next potential position (based on dirgo)

  this.dirticker = new Ticker();
  this.dirfr = dir0; // Initial direction, beginning of tick range
  this.diram = dir0; // Actual direction, ticking to dirbe
  this.dirbe = dir0; // Final direction, end of tick range
  this.dirgo = false; // Future direction for the next tick range
  this.speed = (label=="pacman") ? 200 : 1000-rnd(700);

  /* Get the cardinal distance between dirfr and dirbe [0-8).  dirfr and dirbe should be [0-8).
  */
  this.dirToAngle = function () {
    return (this.dirbe - this.dirfr + 8) % 8;
  }
  /* The direction relative to the current direction 'dirbe' plus delta.  delta = [2=left 4=reverse 6=right]
  */
  this.deltaToDir = function (delta) {
    return (this.dirbe + delta + 8) % 8;
  }
  /* The location relative to the current location plus delta
  */
  this.locPlusDir = function (loc, dir) {
    //if (dir==0) return {x:loc.x + 1, y:loc.y,     z:loc.z};
    //if (dir==4) return {x:loc.x - 1, y:loc.y,     z:loc.z};
    //if (dir==2) return {x:loc.x,     y:loc.y + 1, z:loc.z};
    //if (dir==6) return {x:loc.x,     y:loc.y - 1, z:loc.z};
    return {x:loc.x + cos(dir/8*PI360), y:loc.y + sin(dir/8*PI360), z:loc.z};
    return loc;
  }
  /* Return solid/not-solid of the location at locbe in the delta direction
  */
  this.dirToMapIsSolid = function (dir) {
    var loc = this.locPlusDir(this.locbe, dir);
    return mapIsSolid(loc.x, loc.y);
  }
  this.deltaToMapIsSolid = function (delta) {
    return this.dirToMapIsSolid(this.deltaToDir(delta));
  }

  /* Test if locam has finally ticked its way to locbe
  */
  this.isLocamLocbe = function () {
    return this.locam.x == this.locbe.x &&
           this.locam.y == this.locbe.y &&
           this.locam.z == this.locbe.z;
  }
  /* Slowly translate the Entity to the new location: locam = [locfr -> locbe]
  */
  this.tickLocation = function (time) {
    var p = this.locticker.tick(time); // p goes from 0 to 1
    if (p < 1) {
      var distx = this.locbe.x - this.locfr.x;
      var disty = this.locbe.y - this.locfr.y;
      var distz = this.locbe.z - this.locfr.z;
      var newx = this.locfr.x + (p * distx);
      var newy = this.locfr.y + (p * disty);
      var newz = this.locfr.z + (p * distz);
      this.locam.x = newx;
      this.locam.y = newy;
      this.locam.z = newz;
    } else {
      setLoc(this.locam, this.locbe);
    }
  }
  /* Update entity's location state.  If dirbe points at a valid spot relative to locbe,
     then it updates location
  */
  this.tockLocation = function (time) {
    if (this.isLocamLocbe()) {
      var loc = this.locPlusDir(this.locbe, this.dirbe);
      if (!mapIsSolid(loc.x, loc.y)) {
        setLoc(this.locfr, this.locam);
        setLoc(this.locbe, loc);
        this.locticker.reset(time, this.speed);
        this.locgo = false; // Special hack for ghosts so they choose only 1 new dir each tock
      } else {
        //if (this.label == "pacman") this.randomDirection();
      }
    }
  }
  /* Slowly rotate the Entity to the new direction  diram = [dirfr -> dirbe]
     Rotation movement preceeds location movement.  So the entity turns in the
     direction of the next location, not the current.
  */
  this.tickDirection = function (time) {
    var p = this.dirticker.tick(time);
    if (p < 1) {
      var dist = this.dirToAngle(); // Modulo distance [0-8) of dirfr -> dirbe
      var sdist = (4 <= dist) ? dist-8 : dist;  // signed distance (-4 4]
      this.diram = (this.dirfr + p * sdist + 8) % 8;
    } else {
      this.diram = this.dirbe;
    }
  }
  /* Update entity's direction state.  dirgo, set externally via turnByDelta(), and
     locbe together determine if the rotation should occur.
  */
  this.tockDirection = function (time) {
    if (false !== this.dirgo && !this.dirToMapIsSolid(this.dirgo)) {
      this.dirfr = this.diram;
      this.dirbe = this.dirgo;
      this.dirgo = false;
      this.dirticker.reset(time, 500);
    }
  }
  /*  Entity sets dirgo to a random location relative to locbe if it's not solid
      Try each delta direction and update dirgo if the turn can be done at dirbe, the next spot.
  */
  this.randomDirection = function () {
    if (false === this.locgo) {
      var deltas = [[0,2,6,4],[0,6,2,4],
                    [6,0,2,4],[2,0,6,4],
                    //[6,2,0,4],[2,6,0,4]  ignore these to give more emphasis on moving forward
                   ][rnd(4)];
      while (deltas.length) {
        var dir = this.deltaToDir(deltas.shift());
        if (!this.dirToMapIsSolid(dir)) {
          this.dirgo = dir;
          this.locgo = true;
          break;
        }
      }
    }
  }
  /* Called whenever an incremental change in location and direction needs to occur
      tick is a value [0,1].  A 1 tells it to prepare for a new time slice which means
      set the 'be's to 'go's.
  */
  this.tick = function (time) {
    if (label == "ghost") this.randomDirection(); // For ghosts mainly

    this.tickDirection(time); // Turn a little bit from diram to dirbe
    this.tickLocation(time); // Translate a little from locam to locbe

    this.tockDirection(time);
    this.tockLocation(time);
  }
  /* Translate given a delta relative to locam.  0=forward 2=left 4=reverse 6=right.
     Only affects location.
  */
  this.walkInDirection = function (delta)  {
    var newdir = this.deltaToDir(delta);
    if (0==newdir) this.locbe.x++; else
    if (2==newdir) this.locbe.y++; else
    if (4==newdir) this.locbe.x--; else
    if (6==newdir) this.locbe.y--;
  }
  /* Set new direction given a delta relative to diram.  left=2 right=6 back=4.
     Only affects desired direction.  Actual movement and rotation occurs during tick.
  */
  this.turnByDelta = function (delta)  {
    this.dirgo = this.deltaToDir(delta);
  }
  /* Directly Update current position in a specific direction
  */
  this.tickInDirection = function (angle, amt) {
    this.diram = angle;
    this.locam.x += sin(angle) * amt;
    this.locam.y += cos(angle) * amt;
    this.locam.z = 0.5;
  }
  /* Debug stuff.
  */
  this.dump = function () {
    console.log(label + "  " +
                "fr=(" + this.locfr.x + " " + this.locfr.y + " " + this.locfr.z + ")" + "  " +
                "am=(" + this.locam.x + " " + this.locam.y + " " + this.locam.z + ")" + "  " +
                "be=(" + this.locbe.x + " " + this.locbe.y + " " + this.locbe.z + ")");
  }
} // Entity
//** TEST **********************************************************************
(function TESTEntityTick () {
  var ent = new Entity("ent", [1, 2, 3], 0); // Start off at 1,2,3 dir=0
  var newdir;

  // Rotate from 0 to 1
  ent.dirticker.reset(0, 1000);  ent.dirbe=2;
  ent.tickDirection(100);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 0.2);
  ent.tickDirection(200);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 0.4);
  ent.tickDirection(210);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 0.42);
  ent.tickDirection(500);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 1.0);
  ent.tickDirection(900);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 1.8);
  ent.tickDirection(999);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 1.998);
  ent.tickDirection(1000);  console.log(ent.diram); TESTCmpNumNum (ent.diram, 2);
  ent.tickDirection(1010);  console.log(ent.diram); TESTCmp(ent.diram, 2);

  // Rotate 0 to 7
  ent.dirticker.reset(0, 1000);  ent.dirbe=7;
  ent.tickDirection(100);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 7.9);
  ent.tickDirection(200);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 7.8);
  ent.tickDirection(210);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 7.79);
  ent.tickDirection(500);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 7.5);
  ent.tickDirection(900);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 7.1);
  ent.tickDirection(999);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 7.001);
  ent.tickDirection(1000);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 7);
  ent.tickDirection(1010);  console.log(ent.diram); TESTCmp(ent.diram, 7);

  // Rotate 7 to 1
  ent.dirticker.reset(0, 1000);  ent.dirfr=7;  ent.dirbe=1;
  ent.tickDirection(100);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 7.2);
  ent.tickDirection(200);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 7.4);
  ent.tickDirection(210);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 7.42);
  ent.tickDirection(500);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 0);
  ent.tickDirection(900);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 0.8);
  ent.tickDirection(999);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 0.998);
  ent.tickDirection(1010);  console.log(ent.diram); TESTCmp(ent.diram, 1);

  var newloc;
  ent.locticker.reset(0, 1000);
  ent.locbe.x = 10;
  ent.locbe.y = 12;
  console.log("Moving from [" + ent.locam.x + "," + ent.locam.y + "] to [" + ent.locbe.x + "," + ent.locbe.y + "]" );
  ent.tickLocation(0);    console.log([ent.locam.x, ent.locam.y]); TESTCmpAry([ent.locam.x, ent.locam.y], [1, 2]);
  ent.tickLocation(100);  console.log([ent.locam.x, ent.locam.y]); TESTCmpAry([ent.locam.x, ent.locam.y], [1.9, 3]);
  ent.tickLocation(200);  console.log([ent.locam.x, ent.locam.y]); TESTCmpAry([ent.locam.x, ent.locam.y], [2.8, 4]);
  ent.tickLocation(210);  console.log([ent.locam.x, ent.locam.y]); TESTCmpAry([ent.locam.x, ent.locam.y], [2.89, 4.1]);
  ent.tickLocation(500);  console.log([ent.locam.x, ent.locam.y]); TESTCmpAry([ent.locam.x, ent.locam.y], [5.5, 7]);
  ent.tickLocation(510);  console.log([ent.locam.x, ent.locam.y]); TESTCmpAry([ent.locam.x, ent.locam.y], [5.59, 7.1]);
  ent.tickLocation(999);  console.log([ent.locam.x, ent.locam.y]); TESTCmpAry([ent.locam.x, ent.locam.y], [9.991, 11.99]);
  ent.tickLocation(1000);  console.log([ent.locam.x, ent.locam.y]); TESTCmpAry([ent.locam.x, ent.locam.y], [10, 12]);
  ent.tickLocation(1001);  console.log([ent.locam.x, ent.locam.y]); TESTCmpAry([ent.locam.x, ent.locam.y], [10, 12]);

  console.log("PASS TESTEntityTick");
}());
//******************************************************************************



/*******************************************************************************
 3D Polygonal Convex Surface Models = PM

  * Unit volume between z [-.5 .5] or [0 1] and x/y [-.5 .5]
*******************************************************************************/

function pmGenCubeRGB (l=0.5) {
  return {
    points: [-l, -l, -l,   l, -l, -l,   l, l, -l,   -l, l, -l,
             -l, -l,  l,   l, -l,  l,   l, l,  l,   -l, l,  l],
    faces: [{label:"bottom", fill:"400f", edge:"f00f", face: [0,  1,  2,  3]},
            {label:"top",    fill:"400f", edge:"f00f", face: [7,  6,  5,  4]},
            {label:"front",  fill:"040f", edge:"0f0f", face: [1,  0,  4,  5]},
            {label:"back",   fill:"040f", edge:"0f0f", face: [3,  2,  6,  7]},
            {label:"left",   fill:"004f", edge:"00ff", face: [0,  3,  7,  4]},
            {label:"right",  fill:"004f", edge:"00ff", face: [2,  1,  5,  6]}]};
};

function pmGenCubeSolid (l=0.5, f="008f", e="00ff") {
  return {
    points: [-l, -l, -l,   l, -l, -l,   l, l, -l,   -l, l, -l,
             -l, -l,  l,   l, -l,  l,   l, l,  l,   -l, l,  l],
    faces: [{label:"bottom", fill:f, edge:e, face: [0,  1,  2,  3]},
            {label:"top",    fill:f, edge:e, face: [7,  6,  5,  4]},
            {label:"front",  fill:f, edge:e, face: [1,  0,  4,  5]},
            {label:"back",   fill:f, edge:e, face: [3,  2,  6,  7]},
            {label:"left",   fill:f, edge:e, face: [0,  3,  7,  4]},
            {label:"right",  fill:f, edge:e, face: [2,  1,  5,  6]}]};
};

function pmGenFloor (l=0.5, f="00ff", e="008f") {
  return {
    points: [-l,-l,0,  l,-l,0,  l,l,0,  -l,l,0],
    faces:  [{label:"floor", fill:f, edge:e, face: [0, 3, 2, 1]}]};
}

function pmGenPyramidSolid (l=0.5, f="0f0f", e="080f") {
  return {
    points: [-l,-l,0,  l,-l,0,  l,l,0,  -l,l,0,  0,0,l*2],
    faces: //[["bottom", fill, edge], 0, 1, 2, 3],
           [{label:"front", fill:f, edge:e, face:[ 1, 0, 4]},
            {label:"left",  fill:f, edge:e, face:[ 0, 3, 4]},
            {label:"back",  fill:f, edge:e, face:[ 3, 2, 4]},
            {label:"right", fill:f, edge:e, face:[ 2, 1, 4]}]};
}

function pmGenCubeRainbow (l=0.5) {
  return {
    points: [-l, -l, -l,   l, -l, -l,   l, l, -l,   -l, l, -l,
             -l, -l,  l,   l, -l,  l,   l, l,  l,   -l, l,  l],
    faces: [{label:"bottom", fill:"a00f", edge:"f00f", face: [0,  1,  2,  3]},
            {label:"top",    fill:"0a0f", edge:"0f0f", face: [7,  6,  5,  4]},
            {label:"front",  fill:"00af", edge:"00ff", face: [1,  0,  4,  5]},
            {label:"back",   fill:"0aaf", edge:"0fff", face: [3,  2,  6,  7]},
            {label:"left",   fill:"aa0f", edge:"ff0f", face: [0,  3,  7,  4]},
            {label:"right",  fill:"a0af", edge:"f0ff", face: [2,  1,  5,  6]}]};
}

var pmGen18gon = function (f="880f", e="ff0f", p=0.4142) {
  return {
    points: [-p, -p, 1, // 0
             -p, p, 1,  // 1
              p, p, 1,   // 2
              p, -p, 1,  // 3
               -p, -1, p,  // 4
               -1, -p, p,  // 5
               -1, p, p,   // 6
               -p, 1, p,   // 7
              p, 1, p, // 8
              1, p, p, // 9
              1, -p, p, // 10
              p, -1, p, // 11
               -p, -p, 0, // 12
               -p, p, 0, // 13
               p, p, 0, // 14
               p, -p, 0], // 15
    faces: [ {label:"top", fill:"770f", edge:e, face:[0, 1, 2, 3]},

             {label:"l1", fill:"770f", edge:e, face:[4, 5, 0]},
             {label:"l1", fill:"770f", edge:e, face:[5, 6, 1, 0]},
             {label:"l1", fill:"770f", edge:e, face:[6, 7, 1]},
             {label:"l1", fill:"700f", edge:e, face:[7, 8, 2, 1]},
             {label:"l1", fill:"770f", edge:e, face:[8, 9, 2]},
             {label:"l1", fill:"770f", edge:e, face:[9, 10, 3, 2]},
             {label:"l1", fill:"770f", edge:e, face:[10, 11, 3]},
             {label:"l1", fill:"770f", edge:e, face:[11, 4, 0, 3]},

             {label:"l1", fill:"770f", edge:e, face:[5, 4, 12]},
             {label:"l1", fill:"770f", edge:e, face:[6, 5, 12, 13]},
             {label:"l1", fill:"770f", edge:e, face:[7, 6, 13]},
             {label:"l1", fill:"770f", edge:e, face:[8, 7, 13, 14]},
             {label:"l1", fill:"770f", edge:e, face:[9, 8, 14]},
             {label:"l1", fill:"770f", edge:e, face:[10, 9, 14, 15]},
             {label:"l1", fill:"770f", edge:e, face:[11, 10, 15]},
             {label:"l1", fill:"770f", edge:e, face:[4, 11, 15, 12]},

             {label:"top", fill:"770f", edge:e, face:[15, 14, 13, 12]}]};
};

var pmGenGhost = function () {
  var f="f0fa", fe="f008", e="000f";
  return {
    points:
      [0, 0, .8,    // a0  0
       -.2, -.2, .7,// a1  1
       -.2, .2, .7, // b1  2
       .2, .2, .7,  // c1  3
       .2, -.2, .7, // d1  4
      -.3,  0, .5, // a2  5
        0, .3, .5, // b2  6
      .3,   0, .5, // c2  7
       0, -.3, .5, // d2  8
       -.24, -.24, .5, // aa2 9
       -.24,  .24, .5, // bb2 10
        .24,  .24, .5, // cc2 11
        .24, -.24, .5, // dd2 12
      -.3,   0, .0, // a3 13
        0,  .3, .0, // b3 14
       .3,  .0, .0, // c3 15
        0, -.3, .0, // d3 16
       -.24, -.24, .0, // aa3 17
       -.24,  .24, .0, // bb3 18
        .24,  .24, .0, // cc3 19
        .24, -.24, .0],// dd3 20
    faces:[
     {label:"topa", fill:f, edge:e, face:[0, 1, 2]},
     {label:"topb", fill:f, edge:e, face:[0, 2, 3]},
     {label:"topc", fill:f, edge:e, face:[0, 3, 4]},
     {label:"topd", fill:f, edge:e, face:[0, 4, 1]},

     {label:"mida", fill:f, edge:e, face:[2, 1, 5]},
     {label:"midb", fill:f, edge:e, face:[3, 2, 6]},
     {label:"midc", fill:f, edge:e, face:[4, 3, 7]},
     {label:"midd", fill:f, edge:e, face:[1, 4, 8]},

     {label:"midaal", fill:fe, edge:e, face:[1, 9, 5]},
     {label:"midbbl", fill:f, edge:e, face:[2, 10, 6]},
     {label:"midccl", fill:f, edge:e, face:[3, 11, 7]},
     {label:"midddl", fill:f, edge:e, face:[4, 12, 8]},

     {label:"midaar", fill:f, edge:e, face:[1, 8, 9]},
     {label:"midbbr", fill:fe, edge:e, face:[2, 5, 10]},
     {label:"midccr", fill:f, edge:e, face:[3, 6, 11]},
     {label:"midddr", fill:f, edge:e, face:[4, 7, 12]},

     {label:"lowaa", fill:f, edge:e, face:[17,  5, 9]},
     {label:"lowaa", fill:f, edge:e, face:[17,  13,  5]},
     {label:"lowaa", fill:f, edge:e,  face:[13, 18,  5]},
     {label:"lowaa", fill:f, edge:e, face:[18, 10,  5]},

     {label:"lowaa", fill:f, edge:e, face:[18,  6, 10]},
     {label:"lowaa", fill:f, edge:e, face:[18,  14,  6]},
     {label:"lowaa", fill:f, edge:e, face:[ 14, 19,  6]},
     {label:"lowaa", fill:f, edge:e, face:[19, 11,  6]},

     {label:"lowaa", fill:f, edge:e, face:[19,  7, 11]},
     {label:"lowaa", fill:f, edge:e, face:[19,  15,  7]},
     {label:"lowaa", fill:f, edge:e, face:[ 15, 20,  7]},
     {label:"lowaa", fill:f, edge:e, face:[20, 12,  7]},

     {label:"lowaa", fill:f, edge:e, face:[20,  8, 12]},
     {label:"lowaa", fill:f, edge:e, face:[20,  16,  8]},
     {label:"lowaa", fill:f, edge:e, face:[ 16, 17,  8]},
     {label:"lowaa", fill:f, edge:e, face:[17, 9,  8]}]};
}


function hexToRgb (str) { // "f00f" => {r:255, g:0, b:0, a:1.0}
  var r,g,b,a;
  r = parseInt(str.charAt(0), 16)*17;
  g = parseInt(str.charAt(1), 16)*17;
  b = parseInt(str.charAt(2), 16)*17;
  a = parseInt(str.charAt(3), 16)/15;
  return {r:r, g:g, b:b, a:isNaN(a)?1:a};
}

function pmNormalizeFace (face) {
  face.fill = hexToRgb(face.fill);
  face.edge = hexToRgb(face.edge);
  face.edgeStr = `rgba(${face.edge.r},${face.edge.g},${face.edge.b},${face.edge.a})`;
  return face;
}


/*******************************************************************************
  Create a Polygonal Convex Surface Canvas (PC) from a PM

  {points: [x y z ...]
   faces:  [{label:"top"  fill:"a00f"  edge:"f00f"  face:[1 3 4 ...]} ...] }

  =>

  {label:   "box"
   points:  [1 -2 2  ...]
   center:  [-.5  .5  .5]
   faces:   [{label:"top"  fill:{r:148 g:0 b:0 a:1.0}  edge:{r:255 g:0 b:0 a:1.0}  faces:[1 3 4 ...]} ...]}
   xform:   [1 0 0 0  0 1 0 0  0 0 1 0  0 0 0 1]
   tcenter: null
   tpoints: null
   txform:  null }
    
*******************************************************************************/
function pcGen (label, pm) {
  // Static Fields
  var self = {pg:true, label:label};//Use the label string as the object.  Why not?
  var points = pm.points;
  var count = points.length/3;
  var faces = pm.faces.map(pmNormalizeFace);
  var center = pm.points.reduce( (r,v,i) => (r[i%3]+=v, r), [0,0,0] ).map( v => v/count ); // Append new average-point to points.
  var xform = null; // Base transform.  The seed transform, if any.
  var animator = null; // Callback which usually will update the per-frame temporary-xform below.

  // Mutable temporary vars.  The transformation "canvas".
  var txform = [];
  var tcenter = [];
  var tpoints = [];

  // Methods

  self.setAni = function (ani) { animator = ani; return self; }
  self.tick = function (state) { animator && animator(self, state); return self; }

  self.reset = function () { // Reset canvas
    txform = null;
    tcenter = null;
    tpoints = null;
    return self;
  };

  self.setXform = function (xf) { xform = xf; return self; };

  //    xf * xform => txform  or  xf => txform
  self.leftMulXform = function (xf) {
    if (!xf) { return self; }
    var lxf = txform || xform; // Use the temporary xform, or base xform.
    txform = (lxf ? pgMultXformXformNew(xf, lxf) : xf.slice(0));
    return self;
  }
  self.rightMulXform = function (xf) {
    if (!xf) { return self; }
    var lxf = txform || xform; // Use the crrent temporary xform, or base xform.
    txform = (lxf ? pgMultXformXformNew(lxf, xf) : xf.slice(0));
    return self;
  }

  self.xformCenter = function () {
    if (txform) {
      tcenter = matMul4Mat3VecLinear(txform, center);
    } else {
      tcenter = matMul4Mat3VecLinear(xform, center);
    }
    return self;
  }

  self.xformPoints = function () {
    tpoints = matMul4Mat3VecLinear(txform, points);
    return self;
  }

  self.getCenter = function () {
    return tcenter ? tcenter : center;
  }
  self.getPoints = function () {
    return tpoints;
  }
  self.getFaces = function () { return faces; }

  self.dump = function () {
    console.log((
     `${self.label} c${center.stringify()} ${points.groupby(3).tomap().stringify().replace(/[{}:]/g, '')}\n` +
     `${(xform||[]).groupby(4).map(JSON.stringify).join('\n')}\n` +
     `c${tcenter.stringify()} ${tpoints.groupby(4).tomap().stringify()}\n` +
     `${txform.groupby(4).map(JSON.stringify).join('\n')}\n` +
     `${faces.map(JSON.stringify).join('\n')}`).replace(/"/g,'').replace(/,/g,' '));
    return self;
  };

  return self;
};



function distLocLoc(loc, locb) {
  return Math.sqrt(square(loc.x - locb.x) +
                   square(loc.y - locb.y) +
                   square(loc.z - locb.z));
}


function pgScale (points, a, b, c) {
  var i, v;
  for (i=0; i<points.length; i+=4) { // Over every vector
    points[i] *= a;
    points[i+1] *= b;
    points[i+2] *= c;
  }
}


function pgPerspective (vectors, per) {
  var i, skip=false;
  for (i=0; i<vectors.length; i+=4) { // Over every vector
   var x = vectors[i+0];
   var y = vectors[i+1];
   var z = vectors[i+2];
   var p = per / y;
   vectors[i+0] = x * p;
   vectors[i+2] = z * p;
   if (y < 0 ) skip = true;
  }
  return skip;
}


/* Compute the normal vector of the plane defined by three points
   if Index 1 is positive, then the plan is oriented towards the viewer
*/
function getNormal (v0, v1, v2) {
  var va = [v1[0]-v0[0], v1[1]-v0[1], v1[2]-v0[2]];
  var vb = [v2[0]-v0[0], v2[1]-v0[1], v2[2]-v0[2]];
  return [(va[1] * vb[2]) - (va[2] * vb[1]),
          (va[0] * vb[2]) - (va[2] * vb[0]),
          (va[0] * vb[1]) - (va[1] * vb[0])];
}


/***************************************
  Extend the Array object into a transformation matrix.
  PG_Matrix_library
  * Pretty sure you'd only want to scale first if the model is defined around the origin.
***************************************/
const pgMatrix = (() => {

  Array.prototype.scale = function (x, y, z) {
    var x = arguments.length < 1 ? 1 : x;
    var y = arguments.length < 2 ? x : y;
    var z = arguments.length < 3 ? y : z;
    this.push(...[x,0,0,0, 0,y,0,0, 0,0,z,0, 0,0,0,1]);
    return this;
  }

  /* abcd   x000   ax by cz d
     efgh * 0y00 = ex fy gz h  
     ijkl   00z0   ix jy kz l
     mnop   0001   mx ny oz p */
  Array.prototype.rightScale = function (xx, yy, zz) {
    var x = arguments.length < 1 ? 1 : xx;
    var y = arguments.length < 2 ? x : yy;
    var z = arguments.length < 3 ? y : zz;
    this[0] *= x;  this[1] *= y;  this[2] *= z;
    this[4] *= x;  this[5] *= y;  this[6] *= z;
    this[8] *= x;  this[9] *= y;  this[10]*= z;
    this[12]*= x;  this[13]*= y;  this[14]*= z;
    return this;
  }

  /* Mutate a transformation matrix with a post translation.
     abcd   100x   a  b  c   ax+by+cz+d
     efgh * 010y = e  f  g   ex+fy+gz+h
     ijkl   001z   i  j  k   ix+jy+kz+l
     mnop   0001   m  n  o   mx+ny+oz+p */
  Array.prototype.trans = function (x, y, z) {
    this.push(...[1,0,0,x, 0,1,0,y, 0,0,1,z, 0,0,0,1]);
    return this;
  }

  Array.prototype.rightTrans = function (x, y, z) {
    this[ 3] += this[ 0]*x + this[ 1]*y + this[ 2]*z;
    this[ 7] += this[ 4]*x + this[ 5]*y + this[ 6]*z;
    this[11] += this[ 8]*x + this[ 9]*y + this[10]*z;
    this[15] += this[12]*x + this[13]*y + this[14]*z;
    return this
  }
    
  Array.prototype.rotY = function (ang) {
    var c = cos(ang);
    var s = sin(ang);
    this.push(...[c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]);
    return this;
  }

  /*
   abcd   c0s0   ac+cS  b  as+cc  d
   efgh * 0100 = ec+gS  f  es+gc  h
   ijkl   S0c0   ic+kS  j  is+kc  l
   mnop   0001   mc+oS  n  ms+oc  p*/
  Array.prototype.rightRotY = function (ang) {
    var a, b, c = cos(ang), s = sin(ang);
    a=this[ 0];  b=this[ 2];  this[ 0] = c*a + s*b;  this[ 2] = -s*a + c*b;
    a=this[ 4];  b=this[ 6];  this[ 4] = c*a + s*b;  this[ 6] = -s*a + c*b;
    a=this[ 8];  b=this[10];  this[ 8] = c*a + s*b;  this[10] = -s*a + c*b;
    a=this[12];  b=this[14];  this[12] = c*a + s*b;  this[14] = -s*a + c*b;
    return this;
  }

  Array.prototype.rotX = function (ang) {
    var c = cos(ang);
    var s = sin(ang);
    this.push(...[1,0,0,0, 0,c,-s,0, 0,s,c,0, 0,0,0,1]);
    return this;
  }

  /* abcd   1000   q bc+cs  bS+cc d
     efgh * 0cS0 = e fc+gs  fS+gc h
     ijkl   0sc0   i jc+ks  jS+kc l
     mnop   0001   m nc+os  nS+oc p */
  Array.prototype.rightRotX = function (ang) {
    var a, b, c = cos(ang), s = sin(ang);
    a=this[ 1];  b=this[ 2];  this[ 1] = c*a + s*b;  this[ 2] = -s*a + c*b;
    a=this[ 5];  b=this[ 6];  this[ 5] = c*a + s*b;  this[ 6] = -s*a + c*b;
    a=this[ 9];  b=this[10];  this[ 9] = c*a + s*b;  this[10] = -s*a + c*b;
    a=this[13];  b=this[14];  this[13] = c*a + s*b;  this[14] = -s*a + c*b;
    return this;
  }

  Array.prototype.rotZ = function (ang) {
    var c = cos(ang);
    var s = sin(ang);
    this.push(...[c,-s,0,0, s,c,0,0, 0,0,1,0, 0,0,0,1]);
    return this;
  }

  /* abcd   cS00   ac+bs aS+bc c d
     efgh * sc00 = ec+fs eS+fc g h
     ijkl   0010   ic+js iS+jc k l
     mnop   0001   mc+ns mS+nc o p */
  Array.prototype.rightRotZ = function (ang) {
    var i, a, b, c = cos(ang), s = sin(ang);
    a=this[ 0];  b=this[ 1];  this[ 0] =  c*a + s*b;  this[ 1] = -s*a + c*b;
    a=this[ 4];  b=this[ 5];  this[ 4] =  c*a + s*b;  this[ 5] = -s*a + c*b;
    a=this[ 8];  b=this[ 9];  this[ 8] =  c*a + s*b;  this[ 9] = -s*a + c*b;
    a=this[12];  b=this[13];  this[12] =  c*a + s*b;  this[13] = -s*a + c*b;
    return this;
  }

  return () => [];
})() // pgMatrix 



/* Left multiply a transformation matrix with a list of vectors.  Both are linear arrays.
   [a b c d    [x x2
    e f g h     y y2
    i j k l   * z z2 ...]
    m n o p]
*/
function matMul4Mat3VecLinear (mat, vec) {
  var r, q=0;
  var a=mat[q++], b=mat[q++], c=mat[q++], d=mat[q++];
  var e=mat[q++], f=mat[q++], g=mat[q++], h=mat[q++];
  var i=mat[q++], j=mat[q++], k=mat[q++], l=mat[q++];
  var m=mat[q++], n=mat[q++], o=mat[q++], p=mat[q++];
  var x, y, z, w, res=Array(vec.length/3*4);


  for (r=0; r<vec.length; r+=3) {
     x = vec[r];
     y = vec[r+1];
     z = vec[r+2];
     // w = 1
     res[r/3*4+0] = (x*a + y*b + z*c + d);
     res[r/3*4+1] = (x*e + y*f + z*g + h);
     res[r/3*4+2] = (x*i + y*j + z*k + l);
     res[r/3*4+3] = (x*m + y*n + z*o + p);
  }
  return res;
};

/*
             [[a b c d]    [[A B C D]
 y = x * y =  [e f g h]  *   E F G H]
              [i j k l]      I J K L]
              [m n o p]]     M N O P]]
*/
function pgMultXformXformNew (x, y) {

  var a=x[0], b=x[1], c=x[2], d=x[3];
  var e=x[4], f=x[5], g=x[6], h=x[7];
  var i=x[8], j=x[9], k=x[10], l=x[11];
  var m=x[12], n=x[13], o=x[14], p=x[15];

  var A=y[0], B=y[1], C=y[2], D=y[3];
  var E=y[4], F=y[5], G=y[6], H=y[7];
  var I=y[8], J=y[9], K=y[10], L=y[11];
  var M=y[12], N=y[13], O=y[14], P=y[15];

  var z=Array(16);
  z[0] = a*A + b*E + c*I + d*M;
  z[1] = a*B + b*F + c*J + d*N;
  z[2] = a*C + b*G + c*K + d*O;
  z[3] = a*D + b*H + c*L + d*P;

  z[4] = e*A + f*E + g*I + h*M;
  z[5] = e*B + f*F + g*J + h*N;
  z[6] = e*C + f*G + g*K + h*O;
  z[7] = e*D + f*H + g*L + h*P;

  z[8] = i*A + j*E + k*I + l*M;
  z[9] = i*B + j*F + k*J + l*N;
  z[10] = i*C + j*G + k*K + l*O;
  z[11] = i*D + j*H + k*L + l*P;

  z[12] = m*A + n*E + o*I + p*M;
  z[13] = m*B + n*F + o*J + p*N;
  z[14] = m*C + n*G + o*K + p*O;
  z[15] = m*D + n*H + o*L + p*P;

  return z;
}



/***************************************
  The_map representing the playing field.  Origin
  is bottom left of this array = area[0][0].  Convert an array of
  strings to a grid of numbers.
***************************************/
var arena = [
  "| |                                                          | |",
  " T                                                            T ",
  "| |                                                          | |",
  "                               g                                ",
  "                                                                ",
  "                               g                                ",
  "                                                                ",
  "                               g                                ",
  "                                                                ",
  "                               g                                ",
  "                                                                ",
  "                               g                                ",
  "                                                                ",
  "                               g                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ",//
  " /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /  ",
  "   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /",
  "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ",//
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                           g g g g g                            ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                              xxx                            | |",
  " T                            xpx                             T ",
  "                              xsx                            | |"
].reverse();

var mapWithin = function (x, y) { return (0<=x) && (x<arena[0].length) && (0<=y) && (y<arena.length); }
var mapIsSolid = function (x, y) { return false && mapWithin(x,y) && 5 != arena[y|0][x|0] && 3 != arena[y|0][x|0]; }
var mapIsPill  = function (x, y) { return mapWithin(x,y) && 1 == arena[y|0][x|0]; }

/* Create all objects that make up scene (the maze) and set their starting positions
*/
function spawnObjectsFromMap () {
  arena.forEach( (row, y) => {
      for (var x=0; (x < row.length); ++x) {
        switch (row[x]) {
          case 1 : {
            //scene.push(pcGen("floor", pmGenFloor()).setXform(pgMatrix().trans(x,y,0)))
            break;
          }
          case " " :
            if (rnd(64) == 0) {
              scene.push(pcGen("gravel", pmGenCubeRGB())
                         .setXform(pgMatrix().trans(x,y,0).rightScale(1).rightTrans(0,0,.5))
                         .setAni( (pc, state) => {
                           pc.rightMulXform(pgMatrix().rotZ(state.time/1000))
                         } ));
            }
            break;
          case "x" : { // road
            scene.push(pcGen("floor", pmGenFloor(0.5, "800f", "f00f"))
                       .setXform(pgMatrix().trans(x,y,0)))
            break;
          }
          case "s" : { // special case for user's avatar
            pacman = pcGen("pacman", pmGen18gon())
                     .setXform(pgMatrix().scale(.5))
                     .setAni((pc, state) => { // this polygroupCanvas, state current just {:time}
                       pc.leftMulXform(pgMatrix().trans(pacman.locam.x, pacman.locam.y, pacman.locam.z)
                                                 .rightRotZ(-mouseLookX))});
            scene.push(pacman);
            pacman = new Entity("pacman", [x, y, 0], 2);
            break;
          }
          case "g" : { // special case for ghost
            scene.push(spawnGhost(x, y));
            break;
          }
          case "T" : {
            scene.push(pcGen("iotower", pmGenPyramidSolid(0.5, "f00f", "800f")).setXform(pgMatrix().trans(x,y,0).rightScale(1,1,100)));
            break;
          }
          case "p" : { // turrent (the player AKA pacman AKA the cannon/turret)  For now the fake opponent
            // Notice no xform is set.  The entire transformation is created each tick.
            scene.push(
              pcGen("turret", pmGen18gon())
              .setXform(pgMatrix().trans(x,y,0))
              //.setAni( (pc, state) => {
              //  pc.leftMulXform(pgMatrix().trans(rem.x/2, rem.y/2, 0).rightRotZ(-rem.d))
              //})
            );
            break;
          }
          case "/" : {
            scene.push(pcGen("maze", pmGenCubeRainbow()).setXform(pgMatrix().trans(x,y,0).rightScale(1,1,9).rightTrans(0,0,.5)));
            break;
          }
          case "|" : { // outer wall
            scene.push(pcGen("wall", pmGenCubeSolid()).setXform(pgMatrix().trans(x,y,0).rightScale(1,1,5).rightTrans(0,0,.5)));
            break;
          }
        } // switch
      } // for x
  } );
} // spawnObjectsFromMap()



/*******************************************************************************
 Create the new cannon at the location of the user's avatar/actor.
*******************************************************************************/
function spawnCannon (actor) {
  let e = new Entity("cannon", [actor.locam.x, actor.locam.y, actor.locam.z], actor.diram);
  let body = Body(Trajectory(e, 2, PI10, 20));
  let loc = body.tick();
  scene.push(pcGen("cannon", pmGen18gon())
             .setXform(pgMatrix().scale(1))
             .setAni( (pc, state) => { // this polygroupCanvas, state current just {:time}
               if (loc.z <= 0.0) {
                 pc.leftMulXform(pgMatrix().trans(loc.x, loc.y, 0.0).rightRotZ(state.time/50));
                } else {
                 loc = body.tick(state.time);
                 pc.leftMulXform(pgMatrix().trans(loc.x, loc.y, loc.z).rightRotZ(state.time/50));
               }} ));
  // BF: IPC is still hacky.  Send 'fire' string to everyone for fun.
  if (socket.readyState == socket.OPEN) { socket.send("fire"); }
}


/***************************************
 Create a new Ghost object/actor.
***************************************/
function spawnGhost (x, y) {
  let e = new Entity("ghost", [x, y, 0.5], 4); // BF Entity to be refactored into Actor
  return pcGen("ghost", pmGenGhost())
         .setXform(pgMatrix().rotZ(PI180)) // ghost is rotated
         .setAni((pc, state) => {
           e.tick(currentTime);
           pc.leftMulXform(pgMatrix().trans(e.locam.x, e.locam.y, 0)
                                     .rightRotZ((e.diram)/8 * PI360));
           collision = collision || (distLocLoc(pacman.locam, e.locam) < 0.5) // Detect collision between this ghost and pacman
         } );
}


/*******************************************************************************
 Create a bunch of spinning blocks around the arena.
*******************************************************************************/
function spawnThunderDome () {
  var a;
  /* A perimeter of towers*/
  for (a=0; a<5000; a+=8) {
    scene.push(
      pcGen("dome", pmGenCubeRainbow())
      .setXform(pgMatrix()
                .rotZ(a*PI1)
                .rightRotX(a*PI1/90)
                .rightTrans(0, 100, 0)
                .rightRotY(a*PI1)
                .rightScale(5,5,5))
      .setAni( (pc, state) =>
        pc.rightMulXform(pgMatrix()
                        .rotZ(currentTime/20*PI1)
                        .rightRotY(currentTime/10*PI1)
                        .rightRotX(currentTime/10*PI1)) ));
  }
}



/***************************************
  Globals
***************************************/
var last = {};
var rem = {};
var mouseLookX = PI0;
var mouseLookY = PI0;
var pacman = null;
var quit = false;
var currentTime = getTime();
var collision = false;
var scene = []; // Simple array of renderable object groups.


/***************************************
  Main
***************************************/
function Main () {
  DB("::JavaScriptArtilleryClientV3.0.d");
  var parentStyle = window.getComputedStyle(canvas.parentElement); // Adjust canvas size to parent's size
  var hud = true;
  var gas = [0,0,0,0]; // Literally the gas pedal in the North South East West directions
  var mouseRotX=0, mouseRotY=0;
  var elevation = 2;
  var score=0;
  var frameRateTime=getTime();
  var frameCount=0;
  var frameRate=0;
  var jumper = null;

  function quitToggle () { DB("QUIT"); quit ^= 1; }
  function hudToggle () { hud ^= 1; }
  function gasWalkNorth(v) { gas[0] = v; }
  function gasWalkSouth(v) { gas[1] = v; }
  function gasWalkEast(v)  { gas[2] = v; }
  function gasWalkWest(v)  { gas[3] = v; }
  function heightAdd (x) { elevation += x;  /*if (elevation < 0) elevation = 0;*/ if (400 < 400) elevation = 400; }

  function jump () {
    if (jumper) return;
    jumper = Body(Trajectory(pacman, 15, PI80, 60)); // grav ang vel
  } // Reset next parameterized shell motion at current time.

  spawnObjectsFromMap();
  spawnThunderDome();

  /* Render Loop -- All the animation occurs in this block
  */
  function mainRenderLoop () {
    var clear = 1;
    var currentState = {time:currentTime};
    var sortedVisibleScene=[];
    var pgMatScene;

    currentTime = getTime();

    // Tick pacman
    if (gas[0] || gas[1] || gas[2] || gas[3]) {
      pacman.tickInDirection(
        mouseLookX
         + [[PI315,PI0,PI45],[PI270,PI0,PI90],[PI225,PI180,PI135]][gas[0]-gas[1]+1][gas[2]-gas[3]+1], .2); // magnitude
    }

    // Tick user's avatar jumper Avatar
    if (jumper) {
      let loc = jumper.tick(currentTime);
      let pacman = jumper.entity;
      pacman.locam.x = loc.x;
      pacman.locam.y = loc.y;
      pacman.locam.z = loc.z;
      if (loc.z < 0.5) {
        jumper = null;
        pacman.locam.z = 0.5;
      }
    }

    // Camera transformation matrix.  In reverse order since-left multiplied Mat*[vercies]
    pgMatScene = pgMatrix()
                 .rotX(mouseLookY)
                 .rightRotZ(mouseLookX)
                 .rightTrans(-pacman.locam.x,
                             -pacman.locam.y,
                             -pacman.locam.z-elevation);

    /* Reset and 'tick' each object.  Combine camera xform with object and apply to the center point.
    those objects with center point in fron tof camera go on to the renering phase. */
    scene.forEach ( (pg) => {
      pg.reset()
        .tick(currentState)
        .leftMulXform(pgMatScene) // Combine the individual transform with the camera's transform
        .xformCenter(); // Transform just the center vertex for now
      if (!pgPerspective(pg.getCenter(), 400)) { // Collect groups in front of camera
        sortedVisibleScene.push(pg);
      }
    });

    // Sort the new group of potentially visible groups
    sortedVisibleScene.sort((a,b) => b.getCenter()[1] - a.getCenter()[1]);

    /* Transform and plot each object
    */
    sortedVisibleScene.forEach ( (pg) => {
      pg.xformPoints()
      if (pgPerspective(pg.getPoints(), 400)) return; // skips if any point is behind camera
      pgScale(pg.getPoints(), 1, 200, 1); // Stretch along y-axis so normal calculations are more sane
      var faces = pg.getFaces();
      var points = pg.getPoints();
      for (var f=0; f<faces.length; ++f) {
        var face = faces[f];
        var indices = face.face;
        var i0 = indices[0]*4;
        var i1 = indices[1]*4;
        var i2 = indices[2]*4;

        var v0 = points.slice(i0,i0+3)
        var v1 = points.slice(i1,i1+3)
        var v2 = points.slice(i2,i2+3)

        var theNormal = getNormal(v2, v1, v0);
        if (theNormal[1] <=0) { continue; }

        context.beginPath()
        context.moveTo(v0[0], -v0[2]);
        context.lineTo(v1[0], -v1[2]);
        context.lineTo(v2[0], -v2[2]);

        // Draw the rest of the points
        for (var i=3; i<indices.length; ++i) {
          i0 = indices[i]*4;
          v0 = points.slice(i0,i0+3);
          context.lineTo(v0[0], -v0[2]);
        }

        // Render filled area
        var nx = theNormal[0];
        var ny = theNormal[1];
        var nz = theNormal[2];
        var r = Math.sqrt(nz*nz + ny*ny + nx*nx);
        ny = ny / r; // Normalize the normal's y component
        var fillStyle ="rgba(" + ((ny * face.fill.r) | 0) + "," + // x.round == x|0
                                 ((ny * face.fill.g) | 0) + "," +
                                 ((ny * face.fill.b) | 0) + "," +
                                 (face.fill.a) + ")";

        if (clear) { clearContext(width, height);  clear = 0; }

        context.fillStyle = fillStyle;
        context.fill();

        // Outline the faces
        context.closePath();
        context.strokeStyle = face.edgeStr;
        context.lineWidth = "1"; // Adjust outline width thicker when closer to camera.
        context.stroke();

      } // for faces.length
    }); // for sortedVisibleScene.length

    // Frame rate
    ++frameCount;
    if (frameRateTime+1000 <= currentTime) {
      frameRate = 1000*frameCount/(currentTime - frameRateTime);
      frameRateTime = currentTime;
      frameCount=0;
    }

    if (hud) {
      context.fillStyle = "rgba(0,255,0,1)";
      context.textAlign = "right";
      context.textBaseline = "top";
      context.font = "bold 16px Arial";
      context.fillText(frameRate.toFixed(1), width/2, -height/2);
      //DB.post("Rate", frameRate.toFixed(2));
      //context.fillText("fr   "+pacman.dirfr.toFixed(2) + "(" + pacman.locfr.x.toFixed(2) + " " + pacman.locfr.y.toFixed(2) + ")", -width/2, -height/2+30);
      //context.fillText("am "+pacman.diram.toFixed(2) + "(" + pacman.locam.x.toFixed(2) + " " + pacman.locam.y.toFixed(2) + ")", -width/2, -height/2+60);
      //context.fillText("be  "+pacman.dirbe.toFixed(2) + " (" + pacman.locbe.x.toFixed(2) + " " + pacman.locbe.y.toFixed(2) + ")", -width/2, -height/2+90);
      //context.fillText("go  "+pacman.dirgo,-width/2, -height/2+120);
    }

    // Update server of my wareabouts.
    if (socket.readyState && (last.d != mouseLookX || last.x != pacman.locam.x || last.y != pacman.locam.y)) {
        //var b = Uint8Array.alloc(1+1+8+8+8);
        last.d = mouseLookX;
        last.x = pacman.locam.x;
        last.y = pacman.locam.y;

        var buff = new ArrayBuffer(14);
        var db = new DataView(buff);
        db.setUint8(0, 1); // 1 is move
        db.setUint8(1, 2); // this will be the id
        db.setFloat32(2, last.d);
        db.setFloat32(6, last.x);
        db.setFloat32(10, last.y);
        //DB("sending" + buff.byteLength + " bytes.");
        if (socket.readyState == socket.OPEN) { socket.send(buff); }
    }

    collision = false;

    if (!quit) setTimeout(function(){mainRenderLoop()}, 10);
    else DB ("done.");

  } // mainRenderLoop()

  var flagShift = false;
  var Button_shift = 16;
  var Button_esc = 27;
  var Button_left = 37;
  var Button_up = 38;
  var Button_right = 39;
  var Button_down = 40;
  var Button_minus = 189;
  var Button_equals = 187
  var Button_a = 'A'.charCodeAt();
  var Button_d = 'D'.charCodeAt();
  var Button_f = 'F'.charCodeAt();
  var Button_g = 'G'.charCodeAt();
  var Button_h = 'H'.charCodeAt();
  var Button_i = 'I'.charCodeAt();
  var Button_j = 'J'.charCodeAt();
  var Button_k = 'K'.charCodeAt();
  var Button_l = 'L'.charCodeAt();
  var Button_q = 'Q'.charCodeAt();
  var Button_s = 'S'.charCodeAt();
  var Button_m = 'M'.charCodeAt();
  var Button_space = ' '.charCodeAt();
  var Button_bracketOpen = 219;
  var Button_bracketClose = 221;

  document.body.onkeyup = function () {
    var b = event.keyCode;
    switch (b) {
      case Button_shift : flagShift=false; DB("shift="+flagShift); break;
    }
  };

  document.body.ontouchmove = function (e) {
      DB( e.changedTouches[0].pageX);
      mouseLookX = e.changedTouches[0].pageX * PI1;
      mouseLookY = e.changedTouches[0].pageY * PI1;
      if (mouseLookY < -PI45) mouseLookY = -PI45;
      if (PI45 < mouseLookY) mouseLookY = PI45;
  };


  function mouseControlsLook () {
    document.body.onmousemove = (e) => {
      mouseLookX += e.movementX * PI1;
      mouseLookY += e.movementY * PI1;
      if (mouseLookY < -PI90) mouseLookY = -PI90;
      if (PI90 < mouseLookY) mouseLookY = PI90;
    }
  };


  var enterPointerLock = function () {
    mouseControlsLook();
    document.body.onclick = function (e) {
      if (e.button == 0) { spawnCannon(pacman); }
      if (e.button == 2) { jump(); }
    }
    //gas = 1; // Start motion
  }

  var exitPointerLock = function () {
    document.body.onmousemove = null;
    document.body.onclick = null;
    //gas = -1;
  };

  /* Locked mouse pointer state machine. The exit-pointer-lock state
     is entered at the start.
  */
  ((locked=1) =>
   document.onpointerlockchange = () => {
     if (locked ^= 1) {
       enterPointerLock();
     } else {
       exitPointerLock();
       document.body.onclick = document.body.requestPointerLock;
     }
   })()();

  setTimeout( mouseControlsLook, 1000);


  document.body.onkeydown = function (event) {
    var b = event.keyCode;
    //DB.post("key"+b, "down");
    switch (b) {
      case Button_shift : flagShift=true; break;
      case Button_h :     hudToggle(); break;
      case Button_space : jump(); break;
      case Button_q :     quitToggle(); break;
      case Button_down :
      case Button_a :     gasWalkNorth(1); break;
      case Button_up:
      case Button_s :     gasWalkSouth(1); break;
      case Button_right :
      case Button_f :     gasWalkEast(1);  break;
      case Button_left :
      case Button_d :     gasWalkWest(1); break;
      case Button_equals :  heightAdd(1); break;
      case Button_minus : heightAdd(-1); break;
    }
  }

  document.body.onkeyup = function (event) {
    var b = event.keyCode
    //DB.post("key"+b, "up");
    switch (b) {
      case Button_down :
      case Button_a : gasWalkNorth(0); break;
      case Button_up :
      case Button_s : gasWalkSouth(0); break;
      case Button_right :
      case Button_f : gasWalkEast(0); break;
      case Button_left:
      case Button_d : gasWalkWest(0); break;
    }
  }

  mainRenderLoop();
} // Main



window.onload = function () { Main(); }

var socket = new WebSocket('ws://world.dv8.org:7199')
socket.binaryType = "arraybuffer";

socket.onopen = function (event) {
  DB("websocket connected.");
}

socket.onclose = function (event) {
  DB("websocket closed.");
}


socket.onmessage = function (event) {
  var msg = event.data;
  DB.post("onmsg",  msg.length);
  if (typeof msg == "string") { // String messages are just echoed to console.
    DB.post("str", msg);
  } else if (msg instanceof ArrayBuffer) {
    var dv = new DataView(msg);
    var cmd = dv.getUint8(0);
    var usr = dv.getUint8(1);
    switch (cmd)  {
    case 0:                      // My new user ID from the server.
      // Create my entity / turret object.
      break;
    case 1:                      // User moved and/or rotated.  If new user, create him.
      rem.d = dv.getFloat32(2);
      rem.x = dv.getFloat32(6);
      rem.y = dv.getFloat32(10);
      DB.post(`[mov ${dv.getUint8(1)}]`, `${rem.d.toFixed(2)} ${rem.x.toFixed(2)} ${rem.y.toFixed(2)}`);
      break
    }
  } else {
    DB(`[???] ${typeof msg} ${msg}`);
  }
}


</script></html>
