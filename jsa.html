<html>
<head>
  <style>
    body, canvas, p { background: black; color: #0f0; padding:0; border:0; margin:0; height=100%; width=100%; }
    .off { display:none; }
  </style>
</head>

<body id="pcanvas">
  <canvas id="mycanvas"></canvas>
  <p id="DB" style="position:fixed; right:0; bottom:0; width:20em; max-height:20em; background:#0f01; overflow:auto; white-space:pre"></p>
</body><script>



var stars=document.createElement("img");
stars.src="stars.jpg";
var starsr=document.createElement("img");
starsr.src="starsr.jpg";



/******************************************************************************
  Debug message console and error checking

  DOM requirements::
    <p id="DB"></p>        -- If nonexistent, the DB object will revert to using the browser's console.

  Usage::
    DB("string")           -- Send string to info window.  Behaves like a pre element.
    DB.log("string")       -- Send string to console.log.
    DB.post(type, string)  -- Send string to info window band keeps track of type.  Subsequent typed messages replace the last.
    DB.post(type, string)  -- Send string to info window band keeps track of type.  Subsequent typed messages replace the last.
    DB.clear()             -- Empty the entire DB element.
    DB.check(expr, string) -- If expr is false, send string to console.  status() will then always return false.
    DB.status()            -- Returns false if check ever failed.
******************************************************************************/
var DB = (function () {
  var consoleElement = document.getElementById('DB');
  var self;
  var status = true;
  var shouldNewline = true; // Want to prepend a newline when the last message was plain text.
  var lastPostType = false, lastPost = false;
  var repeatCount = 0;

  var setStyles = function (e) {
    //e.style.border = "solid 1px green";
    //e.style.whiteSpace = "pre";
    //e.style.overflow = "auto";
    //e.style.maxHeight = "20em";
  }

  // Create the instance which is a function.  Also create the clear function.
  if (!consoleElement) {
    self = function (s) { console.log(s); lastPostType = false;}
    self.log = self;
    self.post  = function (t, s) { // For the console, only the first post type is displayed.
      if (t != lastPostType) {
        console.log("[" + t + "]" + s);
        lastPostType = t;
      }
    }
    self.clear = function () { lastPostType = false; }
  } else {
    //setStyles(consoleElement);
    self = function (s) {
      if (lastPost == s) {
       ++repeatCount;
        s = repeatCount + s;
      } else {
        repeatCount = 0;
      }
      consoleElement.innerHTML += (shouldNewline ? "" : "\n") + s;
      consoleElement.scrollTop = consoleElement.scrollHeight;
      shouldNewline = lastPostType = false;
    }
    self.log = function (s) { console.log(s); }
    self.post = function (t, s) {
      if (t == lastPostType) {
        if (lastPost == s) { ++repeatCount; }
        consoleElement.lastChild.innerText = (0<repeatCount ? repeatCount : "") + "[" + t + "]" + s;
      } else {
        consoleElement.appendChild(document.createElement('p')).innerText = "[" + t + "]" + s;
        consoleElement.scrollTop = consoleElement.scrollHeight;
        lastPostType = t;
        repeatCount = 0;
      }
      lastPost = s;
      shouldNewline = true;
    }
    self.clear = function () {
       consoleElement.innerHTML = "";
      shouldNewline = lastPostType = true;
    }
  }

  self.check = function (expr, msg) {
    status = status && expr;
    return expr || self(msg) && false;
  }

  self.status = function () { return status; }

  return self;
})(); // DB




/***************************************
  Unit_testing_infrastructure
  assert(ex)          return true -or- false when exp is false along with a message to console.log
  TESTCmpAry(a, b)    Verify array a and b match (both in size and content)
  TESTCmpAryAry(a, b) Verify array a and b match including the sub-arrays
***************************************/
function assert (exp) {
  if (exp) {
    return true;
  } else {
    console.log("ERROR!");
    return false;
  }
}

function TESTCmp (a, b) {
  if (typeof a == "number") TESTCmpNumNum(a,b)
  else assert(a == b);
}

function TESTCmpNumNum (a, b) {
  //assert(a.toFixed(6) == b.toFixed(6));
  var n = a.toFixed(6);
  var m = b.toFixed(6);
  if (n == "-0.000000") n = "0.000000";
  if (m == "-0.000000") m = "0.000000";
  assert(n == m);
}

function TESTCmpObj (a, b) {
  for (var s in a) TESTCmp(a[s], b[s]);
}

function TESTCmpAry (a, b) {
  var i;
  TESTCmpNumNum(a.length, b.length);
  for (i=0; i<a.length; ++i) TESTCmpNumNum(a[i], b[i]);
}

function TESTCmpAryAry (a, b) {
  var i;
  assert(a.length == b.length);
  for (i=0; i<a.length; ++i) TESTCmpAry(a[i], b[i]);
}



/***************************************
  Global_alises_and_functions
***************************************/
var rnd  = function(n){return Math.floor(Math.random()*n);}
var rndf = function(n){return Math.random()*n;}
var sin = Math.sin;
var cos = Math.cos;
var abs = Math.abs;
var square = function (x) {return x*x;}
var getTime = function () { return (new Date).getTime(); }
var eqpair = function (a, b) {return a.x==b.x && a.y==b.y;}
var setLoc = function (a, b) {a.x=b.x;  a.y=b.y;  a.z=b.z;}
function copyAryAry (a) {
  var i, b = a.slice(0);
  for (i=0; i<b.length; ++i) b[i] = b[i].slice(0);
  return b;
}
Array.prototype.groupby = function (l) { // Group a vector into length l sub vectors.
  return this.reduce( (r,v,i,a) => (i%l || r.push(a.slice(i,i+l)), r), []);
};

Array.prototype.tomap = function () { // Transmogrify an array into a map.
  return this.reduce( (r,v,i) => (r[i]=v, r), {})
}

Object.prototype.stringify = function () { // Transmogrify everything into a map.
  return JSON.stringify(this);
}

Array.prototype.dumpMat = function () {
  console.log(this.map(n=>("     "+n.toFixed(2)).slice(-8)).groupby(4).map(JSON.stringify).join('\n').replace(/"/g,'').replace(/,/g,' '));
  return this;
}

// 3D land counts in radians....base-360, baby.
var PI0   = 0.00000000000000000
var PI1   = 0.017453292519943295
var PI10 = 0.17453292519943295
var PI45  = 0.7853981633974483
var PI80 = 1.3962634015954636
var PI90  = 1.5707963267948966
var PI135 = 2.356194490192345
var PI180 = 3.141592653589793
var PI225 = 3.9269908169872414
var PI270 = 4.71238898038469
var PI315 = 5.497787143782138
var PI360 = 6.283185307179586



/***************************************
  Ticker_class - Keeps track of time for
  linear interpolation.  Returns a value
  between 0 and 1.
***************************************/
function Ticker () {
  this.beg = getTime();
  this.span = 1000;
  this.end = this.beg + this.span;
  this.reset = function (newbeg, newspan) {
    this.beg = newbeg;
    this.span = newspan;
    this.end = this.beg + this.span;
  }
  this.tick = function (time) {
    var p = (time - this.beg) / this.span;
    return (1 < p) ? 1 : p;
  }
}
//** TEST **********************************************************************
(function TESTTicker () {
  var ticker = new Ticker(), p;
  ticker.reset(0, 11);
  p=ticker.tick(0); console.log("tick.tick() = " + p);TESTCmpNumNum(p, 0);
  p=ticker.tick(1); console.log("tick.tick() = " + p);TESTCmpNumNum(p, 0.090909);
  p=ticker.tick(5.5); console.log("tick.tick() = " + p);TESTCmpNumNum(p, 0.5);
  p=ticker.tick(10); console.log("tick.tick() = " + p);TESTCmpNumNum(p, 0.909091);
  p=ticker.tick(11); console.log("tick.tick() = " + p);TESTCmpNumNum(p, 1);
  p=ticker.tick(12); console.log("tick.tick() = " + p);TESTCmpNumNum(p, 1);
  console.log("PASS TESTTicker");
}());
//******************************************************************************



/**************************************************************
 Temporarlly parameterized object interface thingy.

  Usage::
**************************************************************/
function Body (pf, timeMSInitial) { // parameterized function
  var time0 = timeMSInitial || getTime();
  self = function (time) {
    return pf(((time || getTime()) - time0)/1000.0);
  };
  self.tick = self;
  self.entity = pf.entity;
  return self;
}


function Trajectory (ent, gravity, ang, vel) {
  var xyz = ent.locam // Keep track of the starting location and direction of the entity in question..
  var x = xyz.x;
  var y = xyz.y;
  var z = xyz.z;
  var dir = ent.diram;
  var acc = (gravity / -2.0);
  var vh  = (vel * cos(ang)); // Horizontal
  var vy  = (vh * cos(dir)); // Hor.y
  var vx  = (vh * sin(dir)); // Hor.x
  var vv  = (vel * sin(ang)); // Vertical
  var f = (t) => ({x: x + vx * t,
                   y: y + vy * t,
                   z: z + acc * t * t + vv * t})
  f.entity = ent;
  return f;
}


/***************************************
  Entity_class - Models a position and direction
  with the ability to rotate and walk incrementally.

  Used to represent pacman entities that walk around
  a maze and rotate around corners.  Timeline: locfr --locam--> locbe

  Entities state:  location, orientation.  as cartesian matrix and either another matrix and/or angles of rotation

  Associated with polygroups
***************************************/
function Entity (label, aryam, dir0) {
  this.label = label;
  this.mode = 0; // 0 = pacman   1 = ghost

  this.locticker = new Ticker();
  this.locfr = {x:aryam[0], y:aryam[1], z:aryam[2]}; // Initial position, beginning tick range
  this.locam = {x:aryam[0], y:aryam[1], z:aryam[2]}; // Actual location, ticking to locbe
  this.locbe = {x:aryam[0], y:aryam[1], z:aryam[2]}; // Final position, end of tick range
  this.locgo = false;                                // Next potential position (based on dirgo)

  this.dirticker = new Ticker();
  this.dirfr = dir0; // Initial direction, beginning of tick range
  this.diram = dir0; // Actual direction, ticking to dirbe
  this.dirbe = dir0; // Final direction, end of tick range
  this.dirgo = false; // Future direction for the next tick range
  this.speed = (label=="pacman") ? 200 : 1000-rnd(700);

  /* Get the cardinal distance between dirfr and dirbe [0-8).  dirfr and dirbe should be [0-8).
  */
  this.dirToAngle = function () {
    return (this.dirbe - this.dirfr + 8) % 8;
  }
  /* The direction relative to the current direction 'dirbe' plus delta.  delta = [2=left 4=reverse 6=right]
  */
  this.deltaToDir = function (delta) {
    return (this.dirbe + delta + 8) % 8;
  }
  /* The location relative to the current location plus delta
  */
  this.locPlusDir = function (loc, dir) {
    //if (dir==0) return {x:loc.x + 1, y:loc.y,     z:loc.z};
    //if (dir==4) return {x:loc.x - 1, y:loc.y,     z:loc.z};
    //if (dir==2) return {x:loc.x,     y:loc.y + 1, z:loc.z};
    //if (dir==6) return {x:loc.x,     y:loc.y - 1, z:loc.z};
    return {x:loc.x + cos(dir/8*PI360), y:loc.y + sin(dir/8*PI360), z:loc.z};
    return loc;
  }
  /* Return solid/not-solid of the location at locbe in the delta direction
  */
  this.dirToMapIsSolid = function (dir) {
    var loc = this.locPlusDir(this.locbe, dir);
    return mapIsSolid(loc.x, loc.y);
  }
  this.deltaToMapIsSolid = function (delta) {
    return this.dirToMapIsSolid(this.deltaToDir(delta));
  }

  /* Test if locam has finally ticked its way to locbe
  */
  this.isLocamLocbe = function () {
    return this.locam.x == this.locbe.x &&
           this.locam.y == this.locbe.y &&
           this.locam.z == this.locbe.z;
  }
  /* Slowly translate the Entity to the new location: locam = [locfr -> locbe]
  */
  this.tickLocation = function (time) {
    var p = this.locticker.tick(time); // p goes from 0 to 1
    if (p < 1) {
      var distx = this.locbe.x - this.locfr.x;
      var disty = this.locbe.y - this.locfr.y;
      var distz = this.locbe.z - this.locfr.z;
      var newx = this.locfr.x + (p * distx);
      var newy = this.locfr.y + (p * disty);
      var newz = this.locfr.z + (p * distz);
      this.locam.x = newx;
      this.locam.y = newy;
      this.locam.z = newz;
    } else {
      setLoc(this.locam, this.locbe);
    }
  }
  /* Update entity's location state.  If dirbe points at a valid spot relative to locbe,
     then it updates location
  */
  this.tockLocation = function (time) {
    if (this.isLocamLocbe()) {
      var loc = this.locPlusDir(this.locbe, this.dirbe);
      if (!mapIsSolid(loc.x, loc.y)) {
        setLoc(this.locfr, this.locam);
        setLoc(this.locbe, loc);
        this.locticker.reset(time, this.speed);
        this.locgo = false; // Special hack for ghosts so they choose only 1 new dir each tock
      } else {
        //if (this.label == "pacman") this.randomDirection();
      }
    }
  }
  /* Slowly rotate the Entity to the new direction  diram = [dirfr -> dirbe]
     Rotation movement preceeds location movement.  So the entity turns in the
     direction of the next location, not the current.
  */
  this.tickDirection = function (time) {
    var p = this.dirticker.tick(time);
    if (p < 1) {
      var dist = this.dirToAngle(); // Modulo distance [0-8) of dirfr -> dirbe
      var sdist = (4 <= dist) ? dist-8 : dist;  // signed distance (-4 4]
      this.diram = (this.dirfr + p * sdist + 8) % 8;
    } else {
      this.diram = this.dirbe;
    }
  }
  /* Update entity's direction state.  dirgo, set externally via turnByDelta(), and
     locbe together determine if the rotation should occur.
  */
  this.tockDirection = function (time) {
    if (false !== this.dirgo && !this.dirToMapIsSolid(this.dirgo)) {
      this.dirfr = this.diram;
      this.dirbe = this.dirgo;
      this.dirgo = false;
      this.dirticker.reset(time, 500);
    }
  }
  /*  Entity sets dirgo to a random location relative to locbe if it's not solid
      Try each delta direction and update dirgo if the turn can be done at dirbe, the next spot.
  */
  this.randomDirection = function () {
    if (false === this.locgo) {
      var deltas = [[0,2,6,4],[0,6,2,4],
                    [6,0,2,4],[2,0,6,4],
                    //[6,2,0,4],[2,6,0,4]  ignore these to give more emphasis on moving forward
                   ][rnd(4)];
      while (deltas.length) {
        var dir = this.deltaToDir(deltas.shift());
        if (!this.dirToMapIsSolid(dir)) {
          this.dirgo = dir;
          this.locgo = true;
          break;
        }
      }
    }
  }
  /* Called whenever an incremental change in location and direction needs to occur
      tick is a value [0,1].  A 1 tells it to prepare for a new time slice which means
      set the 'be's to 'go's.
  */
  this.tick = function (time) {
    if (label == "ghost") this.randomDirection(); // For ghosts mainly

    this.tickDirection(time); // Turn a little bit from diram to dirbe
    this.tickLocation(time); // Translate a little from locam to locbe

    this.tockDirection(time);
    this.tockLocation(time);
  }
  /* Translate given a delta relative to locam.  0=forward 2=left 4=reverse 6=right.
     Only affects location.
  */
  this.walkInDirection = function (delta)  {
    var newdir = this.deltaToDir(delta);
    if (0==newdir) this.locbe.x++; else
    if (2==newdir) this.locbe.y++; else
    if (4==newdir) this.locbe.x--; else
    if (6==newdir) this.locbe.y--;
  }
  /* Set new direction given a delta relative to diram.  left=2 right=6 back=4.
     Only affects desired direction.  Actual movement and rotation occurs during tick.
  */
  this.turnByDelta = function (delta)  {
    this.dirgo = this.deltaToDir(delta);
  }
  /* Directly Update current position in a specific direction
  */
  this.tickInDirection = function (angle, amt) {
    this.diram = angle;
    this.locam.x += sin(angle) * amt;
    this.locam.y += cos(angle) * amt;
    this.locam.z = 0.5;
  }
  /* Debug stuff.
  */
  this.dump = function () {
    console.log(label + "  " +
                "fr=(" + this.locfr.x + " " + this.locfr.y + " " + this.locfr.z + ")" + "  " +
                "am=(" + this.locam.x + " " + this.locam.y + " " + this.locam.z + ")" + "  " +
                "be=(" + this.locbe.x + " " + this.locbe.y + " " + this.locbe.z + ")");
  }
} // Entity
//** TEST **********************************************************************
(function TESTEntityTick () {
  var ent = new Entity("ent", [1, 2, 3], 0); // Start off at 1,2,3 dir=0
  var newdir;

  // Rotate from 0 to 1
  ent.dirticker.reset(0, 1000);  ent.dirbe=2;
  ent.tickDirection(100);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 0.2);
  ent.tickDirection(200);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 0.4);
  ent.tickDirection(210);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 0.42);
  ent.tickDirection(500);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 1.0);
  ent.tickDirection(900);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 1.8);
  ent.tickDirection(999);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 1.998);
  ent.tickDirection(1000);  console.log(ent.diram); TESTCmpNumNum (ent.diram, 2);
  ent.tickDirection(1010);  console.log(ent.diram); TESTCmp(ent.diram, 2);

  // Rotate 0 to 7
  ent.dirticker.reset(0, 1000);  ent.dirbe=7;
  ent.tickDirection(100);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 7.9);
  ent.tickDirection(200);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 7.8);
  ent.tickDirection(210);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 7.79);
  ent.tickDirection(500);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 7.5);
  ent.tickDirection(900);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 7.1);
  ent.tickDirection(999);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 7.001);
  ent.tickDirection(1000);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 7);
  ent.tickDirection(1010);  console.log(ent.diram); TESTCmp(ent.diram, 7);

  // Rotate 7 to 1
  ent.dirticker.reset(0, 1000);  ent.dirfr=7;  ent.dirbe=1;
  ent.tickDirection(100);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 7.2);
  ent.tickDirection(200);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 7.4);
  ent.tickDirection(210);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 7.42);
  ent.tickDirection(500);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 0);
  ent.tickDirection(900);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 0.8);
  ent.tickDirection(999);  console.log(ent.diram); TESTCmpNumNum(ent.diram, 0.998);
  ent.tickDirection(1010);  console.log(ent.diram); TESTCmp(ent.diram, 1);

  var newloc;
  ent.locticker.reset(0, 1000);
  ent.locbe.x = 10;
  ent.locbe.y = 12;
  console.log("Moving from [" + ent.locam.x + "," + ent.locam.y + "] to [" + ent.locbe.x + "," + ent.locbe.y + "]" );
  ent.tickLocation(0);    console.log([ent.locam.x, ent.locam.y]); TESTCmpAry([ent.locam.x, ent.locam.y], [1, 2]);
  ent.tickLocation(100);  console.log([ent.locam.x, ent.locam.y]); TESTCmpAry([ent.locam.x, ent.locam.y], [1.9, 3]);
  ent.tickLocation(200);  console.log([ent.locam.x, ent.locam.y]); TESTCmpAry([ent.locam.x, ent.locam.y], [2.8, 4]);
  ent.tickLocation(210);  console.log([ent.locam.x, ent.locam.y]); TESTCmpAry([ent.locam.x, ent.locam.y], [2.89, 4.1]);
  ent.tickLocation(500);  console.log([ent.locam.x, ent.locam.y]); TESTCmpAry([ent.locam.x, ent.locam.y], [5.5, 7]);
  ent.tickLocation(510);  console.log([ent.locam.x, ent.locam.y]); TESTCmpAry([ent.locam.x, ent.locam.y], [5.59, 7.1]);
  ent.tickLocation(999);  console.log([ent.locam.x, ent.locam.y]); TESTCmpAry([ent.locam.x, ent.locam.y], [9.991, 11.99]);
  ent.tickLocation(1000);  console.log([ent.locam.x, ent.locam.y]); TESTCmpAry([ent.locam.x, ent.locam.y], [10, 12]);
  ent.tickLocation(1001);  console.log([ent.locam.x, ent.locam.y]); TESTCmpAry([ent.locam.x, ent.locam.y], [10, 12]);

  console.log("PASS TESTEntityTick");
}());
//******************************************************************************



/*******************************************************************************
 2nd Generation 3D Models

 PolyCon - polygonal convex surfaces
  * Unit volume between z [0 1] and x/y [-1/2 1/2]
*******************************************************************************/

/* Generate Polygonal Convex Surfaces
*/

function pcsGenCubeRGB (l) {
  var l = l || 0.5;
  return {
    points: [-l, -l, -l,   l, -l, -l,   l, l, -l,   -l, l, -l,
             -l, -l,  l,   l, -l,  l,   l, l,  l,   -l, l,  l],
    faces: [{label:"bottom", fill:"400f", edge:"f00f", face: [0,  1,  2,  3]},
            {label:"top",    fill:"400f", edge:"f00f", face: [7,  6,  5,  4]},
            {label:"front",  fill:"040f", edge:"0f0f", face: [1,  0,  4,  5]},
            {label:"back",   fill:"040f", edge:"0f0f", face: [3,  2,  6,  7]},
            {label:"left",   fill:"004f", edge:"00ff", face: [0,  3,  7,  4]},
            {label:"right",  fill:"004f", edge:"00ff", face: [2,  1,  5,  6]}]};
};

function pcsGenCubeSolid (l, f, e) {
  var l = l || 0.5;
  var f = f || "008f";
  var e = e || "00ff";
  return {
    points: [-l, -l, -l,   l, -l, -l,   l, l, -l,   -l, l, -l,
             -l, -l,  l,   l, -l,  l,   l, l,  l,   -l, l,  l],
    faces: [{label:"bottom", fill:f, edge:e, face: [0,  1,  2,  3]},
            {label:"top",    fill:f, edge:e, face: [7,  6,  5,  4]},
            {label:"front",  fill:f, edge:e, face: [1,  0,  4,  5]},
            {label:"back",   fill:f, edge:e, face: [3,  2,  6,  7]},
            {label:"left",   fill:f, edge:e, face: [0,  3,  7,  4]},
            {label:"right",  fill:f, edge:e, face: [2,  1,  5,  6]}]};
};

function pcsGenFloor (l, f, e) {
  var l = l || 0.5;
  var f = f || "00ff";
  var e = e || "008f";
  return {
    points: [-l,-l,0,  l,-l,0,  l,l,0,  -l,l,0],
    faces:  [{label:"floor", fill:f, edge:e, face: [0, 3, 2, 1]}]};
}

function pcsGenPyramidSolid (l, f, e) {
  var l = l || 0.5
  var f = f || "0f0f";
  var e = e || "080f";
  return {
    points: [-l,-l,0,  l,-l,0,  l,l,0,  -l,l,0,  0,0,l*2],
    faces: //[["bottom", fill, edge], 0, 1, 2, 3],
           [{label:"front", fill:f, edge:e, face:[ 1, 0, 4]},
            {label:"left",  fill:f, edge:e, face:[ 0, 3, 4]},
            {label:"back",  fill:f, edge:e, face:[ 3, 2, 4]},
            {label:"right", fill:f, edge:e, face:[ 2, 1, 4]}]};
}

function pcsGenCubeRainbow (l) {
  var l = l || 0.5;
  return {
    points: [-l, -l, -l,   l, -l, -l,   l, l, -l,   -l, l, -l,
             -l, -l,  l,   l, -l,  l,   l, l,  l,   -l, l,  l],
    faces: [{label:"bottom", fill:"a00f", edge:"f00f", face: [0,  1,  2,  3]},
            {label:"top",    fill:"0a0f", edge:"0f0f", face: [7,  6,  5,  4]},
            {label:"front",  fill:"00af", edge:"00ff", face: [1,  0,  4,  5]},
            {label:"back",   fill:"0aaf", edge:"0fff", face: [3,  2,  6,  7]},
            {label:"left",   fill:"aa0f", edge:"ff0f", face: [0,  3,  7,  4]},
            {label:"right",  fill:"a0af", edge:"f0ff", face: [2,  1,  5,  6]}]};
}

//var pspec_maze    = pspecGenerateUnitCube("maze", "#88f7", "#00ff");
//var pspec_pill    = pspecGenerateUnitCube("pill", "#fff9", "#ffff");

function hexToRgb (str) { // "f00f" => {r:255, g:0, b:0, a:1.0}
  r = parseInt(str.charAt(0), 16)*17;
  g = parseInt(str.charAt(1), 16)*17;
  b = parseInt(str.charAt(2), 16)*17;
  a = parseInt(str.charAt(3), 16)/15;
  return {r:r, g:g, b:b, a:isNaN(a)?1:a};
}

function pcsNormalizeFace (face) {
  face.fill = hexToRgb(face.fill);
  face.edge = hexToRgb(face.edge);
  face.edgeStr = `rgba(${face.edge.r},${face.edge.g},${face.edge.b},${face.edge.a})`;
  return face;
}


/*
  Create a Polygonal Convex Surface Canvas from a basic PCS. Convert:

   {points: [x y z ...]
    faces:  [{label:"top"  fill:"a00f"  edge:"f00f"  face:[1 3 4 ...]} ...] }

  and a label into:

   {label:  "box"
    points: [1 -2 2  ...]
    center: [-.5  .5  .5]
    faces:  [{label:"top"  fill:{r:148 g:0 b:0 a:1.0}  edge:{r:255 g:0 b:0 a:1.0}  faces:[1 3 4 ...]} ...]}
    xform:  [1 0 0 0  0 1 0 0  0 0 1 0  0 0 0 1]
    tcenter: null
    tpoints: null
    txform:  null }

  TODO:
    Register a schene container that automatically adds the model during construction.

  Object Xform Timeline:
    Preliminary static xform (scale, translation)  Apply to static points if non animated prop.
    
*/

function pcGen (label, pcs) {
  // Static Fields
  var self = {pg:true, label:label};//Use the label string as the object.  Why not?
  var points = pcs.points;
  var count = points.length/3;
  var faces = pcs.faces.map(pcsNormalizeFace);
  var center = pcs.points.reduce( (r,v,i) => (r[i%3]+=v, r), [0,0,0] ).map( v => v/count ); // Append new average-point to points.
  var xform = null;
  var animator = null;

  // Mutable fields.  The transformation Canvas.
  var txform = [];
  var tcenter = [];
  var tpoints = [];

  // Methods

  self.setAni = function (ani) { animator = ani; return self; }
  self.tick = function (state) { animator && animator(self, state); return self; }

  self.reset = function () { // Reset canvas
    txform = null;
    tcenter = null;
    tpoints = null;
    return self;
  };

  self.setXform = function (xf) { xform = xf; return self; };

  //    xf * xform => txform  or  xf => txform
  self.leftMulXform = function (xf) {
    if (!xf) { return self; }
    var lxf = txform || xform; // Use the temporary xform, or base xform.
    txform = (lxf ? pgMultXformXformNew(xf, lxf) : xf.slice(0));
    return self;
  }
  self.rightMulXform = function (xf) {
    if (!xf) { return self; }
    var lxf = txform || xform; // Use the temporary xform, or base xform.
    txform = (lxf ? pgMultXformXformNew(lxf, xf) : xf.slice(0));
    return self;
  }

  self.xformCenter = function () {
    if (txform) {
      tcenter = matMul4Mat3VecLinear(txform, center);
    } else {
      tcenter = matMul4Mat3VecLinear(xform, center);
    }
    return self;
  }

  self.xformPoints = function () {
    tpoints = matMul4Mat3VecLinear(txform, points);
    return self;
  }

  self.getCenter = function () {
    return tcenter ? tcenter : center;
  }
  self.getPoints = function () {
    return tpoints;
  }
  self.getFaces = function () { return faces; }

  self.dump = function () {
    console.log((
     `${label} c${center.stringify()} ${points.groupby(3).tomap().stringify().replace(/[{}:]/g, '')}\n` +
     `${(xform||[]).groupby(4).map(JSON.stringify).join('\n')}\n` +
     `c${tcenter.stringify()} ${tpoints.groupby(4).tomap().stringify()}\n` +
     `${txform.groupby(4).map(JSON.stringify).join('\n')}\n` +
     `${faces.map(JSON.stringify).join('\n')}`).replace(/"/g,'').replace(/,/g,' '));
    return self;
  };

  return self;
};



/***************************************
  The_models Model specification's are functionally generated of the form:

  ["label",                                           Name of model
   [vertices],                                        Array of vertices
   [[label, fillColor, edgeColor], vertexIndex,...],  A polygon representing a face of the object
   ...                                                More faces
  ]

  These need to be compiled into model objects for consumption by this program.

  I tried representing objects within a unit volume.  I'll now try a normalized volume which
  is defined starting at the origin and extending no more than 1 in any direction.

  An array of vertices and a separate array of faces composed of indices into the vertex array.
  I wonder if this is the definition of a mesh.
***************************************/

var pspec_simple = (function () {
  return [
    "simple",                    // Name/label
    //   0        1        2     // Vertices
    [[-1,0,0], [1,0,0], [0,1,0]],
    [["triangle", "#0f0", "#f0f"], 0, 1, 2]]; // First and only face
})();


/* generate a ghost
*/
var pspec_ghost = (function () {
  var fill="#f0fa", feye="#f008", edge="#000f";
  var vectors = [
      [0, 0, .8],    // a0  0
      [-.2, -.2, .7],// a1  1
      [-.2, .2, .7], // b1  2
      [.2, .2, .7],  // c1  3
      [.2, -.2, .7], // d1  4
     [-.3,  0, .5], // a2  5
     [  0, .3, .5], // b2  6
     [.3,   0, .5], // c2  7
     [ 0, -.3, .5], // d2  8
      [-.24, -.24, .5], // aa2 9
      [-.24,  .24, .5], // bb2 10
      [ .24,  .24, .5], // cc2 11
      [ .24, -.24, .5], // dd2 12
     [-.3,   0, .0], // a3 13
     [  0,  .3, .0], // b3 14
     [ .3,  .0, .0], // c3 15
     [  0, -.3, .0], // d3 16
      [-.24, -.24, .0], // aa3 17
      [-.24,  .24, .0], // bb3 18
      [ .24,  .24, .0], // cc3 19
      [ .24, -.24, .0]];// dd3 20
  return ["ghost", vectors,
    [["topa", fill, edge], 0, 1, 2],
    [["topb", fill, edge], 0, 2, 3],
    [["topc", fill, edge], 0, 3, 4],
    [["topd", fill, edge], 0, 4, 1],

    [["mida", fill, edge], 2, 1, 5],
    [["midb", fill, edge], 3, 2, 6],
    [["midc", fill, edge], 4, 3, 7],
    [["midd", fill, edge], 1, 4, 8],

    [["midaal", feye, edge], 1, 9, 5],
    [["midbbl", fill, edge], 2, 10, 6],
    [["midccl", fill, edge], 3, 11, 7],
    [["midddl", fill, edge], 4, 12, 8],

    [["midaar", fill, edge], 1, 8, 9],
    [["midbbr", feye, edge], 2, 5, 10],
    [["midccr", fill, edge], 3, 6, 11],
    [["midddr", fill, edge], 4, 7, 12],

    [["lowaa", fill, edge], 17,  5, 9],
    [["lowaa", fill, edge], 17,  13,  5],
    [["lowaa", fill, edge],  13, 18,  5],
    [["lowaa", fill, edge], 18, 10,  5],

    [["lowaa", fill, edge], 18,  6, 10],
    [["lowaa", fill, edge], 18,  14,  6],
    [["lowaa", fill, edge],  14, 19,  6],
    [["lowaa", fill, edge], 19, 11,  6],

    [["lowaa", fill, edge], 19,  7, 11],
    [["lowaa", fill, edge], 19,  15,  7],
    [["lowaa", fill, edge],  15, 20,  7],
    [["lowaa", fill, edge], 20, 12,  7],

    [["lowaa", fill, edge], 20,  8, 12],
    [["lowaa", fill, edge], 20,  16,  8],
    [["lowaa", fill, edge],  16, 17,  8],
    [["lowaa", fill, edge], 17, 9,  8]];
})();


var pspec_pacman = (function () {
  var edge="#ff0f";
  var p=0.4142;
  var vertices = [
        [-p, -p, 1], // 0
        [-p, p, 1],  // 1
        [p, p, 1],   // 2
        [p, -p, 1],  // 3
     [-p, -1, p],  // 4
     [-1, -p, p],  // 5
     [-1, p, p],   // 6
     [-p, 1, p],   // 7
       [p, 1, p], // 8
       [1, p, p], // 9
       [1, -p, p], // 10
       [p, -1, p], // 11
     [-p, -p, 0], // 12
     [-p, p, 0], // 13
     [p, p, 0], // 14
     [p, -p, 0]]; // 15
  return ["pacman", vertices,
  [["top", "#770f", edge], 0, 1, 2, 3],

  [["l1", "#770f", edge], 4, 5, 0],
  [["l1", "#770f", edge], 5, 6, 1, 0],
  [["l1", "#770f", edge], 6, 7, 1],
  [["l1", "#770f", edge], 7, 8, 2, 1],
  [["l1", "#770f", edge], 8, 9, 2],
  [["l1", "#770f", edge], 9, 10, 3, 2],
  [["l1", "#770f", edge], 10, 11, 3],
  [["l1", "#770f", edge], 11, 4, 0, 3],

  [["l1", "#770f", edge], 5, 4, 12],
  [["l1", "#770f", edge], 6, 5, 12, 13],
  [["l1", "#770f", edge], 7, 6, 13],
  [["l1", "#770f", edge], 8, 7, 13, 14],
  [["l1", "#770f", edge], 9, 8, 14],
  [["l1", "#770f", edge], 10, 9, 14, 15],
  [["l1", "#770f", edge], 11, 10, 15],
  [["l1", "#770f", edge], 4, 11, 15, 12],

  [["top", "#770f", edge], 15, 14, 13, 12]];
})();



/***************************************
  Face_object construction
    { label:    "",          Name of this face
      colorFill:{r=0,g=128,b=255,a=1}    Inner fill color
      colorEdge:{r=0,g=128,b=255,a=1}    Border color
      colorEdgeStr:{r,g,b,a}    Border color
      indices:  [5,0,2,...], Indices to an array of vertices that define one of the model's face
      visible: true          Other flags...
    }
***************************************/
function colorHashToRGB (str) {
  var skipHash = str.charAt(0) == "#" ? 1 : 0;
  r = parseInt(str.charAt(skipHash + 0), 16)*17;
  g = parseInt(str.charAt(skipHash + 1), 16)*17;
  b = parseInt(str.charAt(skipHash + 2), 16)*17;
  a = parseInt(str.charAt(skipHash + 3), 16)/15;
  if (isNaN(a)) a = 1;
  return {r:r, g:g, b:b, a:a};
}

function faceNew (desc, indices) {
  var colorFill = colorHashToRGB(desc[1]);
  var colorEdge = colorHashToRGB(desc[2]);

  return {label:     desc[0],
          colorFill: colorFill,
          colorEdge: colorEdge,
          colorEdgeStr: `rgba(${colorEdge.r},${colorEdge.g},${colorEdge.b},${colorEdge.a})`,
          indices:   indices}
}
//** TEST **********************************************************************
(function TESTfaceNew () {
  var face = faceNew(["testLabel", "#32Fe", "#F200"], [1,2,3]);
  TESTCmpObj(face.colorFill, {r:51,  g:34, b:255, a:0.933333});
  TESTCmpObj(face.colorEdge, {r:255, g:34, b:0,   a:0});
  console.log(face.colorFill);
  console.log(face.colorEdge);
  console.log("PASS TESTfaceNew");
})();
//******************************************************************************




/***************************************
  Group_object Create a 3d object (convex enclosure of convex faces) for transforming
  a model:

    [ "name",
      [[vertex],...],
      [[label, colorFill, colorEdge], vertex_index,...]...
    ]

  => into a group:

    {label:        "object name",
     verticesBase: [vertex,..., midPoint], Original vertices
     transformBase:[4x4 matrix],           Base transform for base vertices
     faces:        [FaceObject,...],
     invisible:    false,
     transform:    [4x4 matrix],           Mutable transformation matrix
     vertices:     [vertex,...],           Mutable vertices
     vertexCenter: [vertex]}               Array containing the center vertex

 The last vertex represents the mid vector of all points.  It's used for sorting
 during rendering.
***************************************/
function groupInitialize (pspec) {
  var newGroup={};
  var vertices, face, desc;
  var count=0, x=0, y=0, z=0; // Used to find the center pointer of object

  newGroup.label = pspec[0];
  newGroup.verticesBase = vertices = copyAryAry(pspec[1]);
  newGroup.vertices = [];
  newGroup.vertexCenter = []; // Array of
  newGroup.transformBase = false;
  newGroup.faces = [];
  newGroup.invisible = false;

  for (var f=0; f<pspec.length-2; ++f) {
    face = pspec[f+2]; // +2 to skip over the "name" and vertices
    // Pass desc and indices separately
    desc = face[0];
    face = face.slice(1);
    newGroup.faces[f] = faceNew(desc, face);
  }

  // Average each x, y and z points to determine center of all points
  for (var v=0; v<vertices.length; ++v) {
    var pts = vertices[v];
    x += pts[0];
    y += pts[1];
    z += pts[2];
    ++count;
  }

  // Add center point to vertices
  newGroup.verticesBase.push([x/count, y/count, z/count]);

  return newGroup;
}
//** TEST **********************************************************************
(function TESTgroupInitialize () {
  var group = groupInitialize(pspec_simple);
  TESTCmpAry(group.verticesBase[0], [-1,0,0]);
  TESTCmpAry(group.verticesBase[1], [1,0,0]);
  TESTCmpAry(group.verticesBase[2], [0,1,0]);
  TESTCmpAry(group.verticesBase[3], [0, 0.333333,0]);
  TESTCmpAry(group.faces[0].indices, [0, 1, 2]);
  TESTCmp(group.verticesBase.length, 4);

  console.log("PASS TESTgroupInitialize");
})();
//******************************************************************************



/* Copies group's verticesBase to vertices for transforming
*/
function groupLoadVerticesBase (group) {
   for (var i=0; i<group.verticesBase.length; ++i) {
     group.vertices[i] = group.verticesBase[i].slice(0); // Replace each vector with a new one
   }
}
//** TEST **********************************************************************
(function TESTgroupLoadVerticesOriginal () {
  var g = groupInitialize(pspec_simple);
  // Perform the load
  groupLoadVerticesBase(g);
  // Modify copied verticies
  g.vertices[0][1]=8;
  g.vertices[0][2]=9;
  g.vertices[3][0]=7;
  g.vertices[3][2]=6;
  // Verify points
  TESTCmp(g.verticesBase.length, 4);
  TESTCmp(g.vertices.length, 4);
  TESTCmpAryAry(g.verticesBase, [[-1,0,0],[1,0,0],[0,1,0],[0, 0.333333,0]]);
  TESTCmpAryAry(g.vertices,         [[-1,8,9],[1,0,0],[0,1,0],[7, 0.333333,6]]);
  console.log("PASS TESTfaceLoadVerticesOriginal");
})();
//******************************************************************************

function distLocLoc(loc, locb) {
  return Math.sqrt(square(loc.x - locb.x) +
                   square(loc.y - locb.y) +
                   square(loc.z - locb.z));
}
function distLocVertex(loc, vertex) {
  return Math.sqrt(square(2*loc.x - vertex[0]) +
                   square(2*loc.y - vertex[1]) +
                   square(2*loc.z - vertex[2]));
}


/***************************************
  Vertex_transforms
  Copy and transform matrices and lists of vectors
***************************************/
function groupTransformMatVerticesOriginal (mat, group) {
  groupLoadVerticesBase(group);
  matMultMatVecs(mat, group.vertices);
}

/* Transform group center vertices by mat
*/
function groupTransformMatVertexCenter (mat, group) {
  // So we can use the general list of points transformation function, create a list of lenght 1 point.
  group.vertexCenter[0] = group.verticesBase[group.verticesBase.length-1].slice(0);
  matMultMatVecs(mat, group.vertexCenter);
}


/*
    3 multiplies
    0 additions
    3 reads
    3 writes
*/
function scale (vectors, a, b, c) {
  for (i=0; i<vectors.length; ++i) { // Over every vector
   var v = vectors[i]; // Consider vector
    v[0] *= a;
    v[1] *= b;
    v[2] *= c;
  }
}


function rotateZ (vectors, angle) {
  for (i=0; i<vectors.length; ++i) { // Over every vector
   var v = vectors[i]; // Consider vector
   var x = v[0];
   var y = v[1];
    v[0] = x*cos(angle) - y*sin(angle); // Mutate x
    v[1] = y*cos(angle) + x*sin(angle); // Mutate y
  }
}

function perspective (vectors, per) {
  var skip=false;
  for (i=0; i<vectors.length; ++i) { // Over every vector
   var v = vectors[i]; // Consider vector
   var x = v[0];
   var y = v[1];
   var z = v[2];
   var p = per / y;
   v[0] = x * p;
   v[2] = z * p;
   if (y < 0 ) skip = true;
  }
  return skip;
}
function pgPerspective (vectors, per) {
  var skip=false;
  for (i=0; i<vectors.length; i+=4) { // Over every vector
   var x = vectors[i+0];
   var y = vectors[i+1];
   var z = vectors[i+2];
   var p = per / y;
   vectors[i+0] = x * p;
   vectors[i+2] = z * p;
   if (y < 0 ) skip = true;
  }
  return skip;
}


/* Transform all the original vertices for each face in the group.
*/
function scaleGroupVerticesOriginal (group, x, y, z) {
  scale(group.verticesBase, x, y, z);
  return group;
}
//** TEST **********************************************************************
(function TESTscaleGroupVerticesOriginal () {
  var g = groupInitialize(pspec_simple);
  // Perform the scale transformation
  scaleGroupVerticesOriginal(g, 2, 2, 2);
  // Verify points
  TESTCmp(g.verticesBase.length, 4);
  TESTCmpAryAry(g.verticesBase, [[-2,0,0],[2,0,0],[0,2,0],[0, 0.666667,0]]);
  console.log("PASS TESTscaleGroupVerticesOriginal ");
})();
//******************************************************************************



/* Compute the normal vector of the plane defined by three points
   if Index 1 is positive, then the plan is oriented towards the viewer
*/
function getNormal (v0, v1, v2) {
  var va = [v1[0]-v0[0], v1[1]-v0[1], v1[2]-v0[2]];
  var vb = [v2[0]-v0[0], v2[1]-v0[1], v2[2]-v0[2]];
  return [(va[1] * vb[2]) - (va[2] * vb[1]),
          (va[0] * vb[2]) - (va[2] * vb[0]),
          (va[0] * vb[1]) - (va[1] * vb[0])];
}


/***************************************

  PG_Matrix_library
  * Pretty sure you'd only want to scale first if the model is defined around the origin.

***************************************/
function pgMatrix() {
  var mat=[];

  mat.scale = function (x, y, z) {
    var x = arguments.length < 1 ? 1 : x;
    var y = arguments.length < 2 ? x : y;
    var z = arguments.length < 3 ? y : z;
    mat.push(...[x,0,0,0, 0,y,0,0, 0,0,z,0, 0,0,0,1]);
    return mat;
  }
  mat.trans = function (x, y, z) {
    mat.push(...[1,0,0,x, 0,1,0,y, 0,0,1,z, 0,0,0,1]);
    return mat;
  }

  mat.rightScale = function (xx, yy, zz) {
    var x = arguments.length < 1 ? 1 : xx;
    var y = arguments.length < 2 ? x : yy;
    var z = arguments.length < 3 ? y : zz;
    mat[0] *= x;  mat[1] *= y;  mat[2] *= z;
    mat[4] *= x;  mat[5] *= y;  mat[6] *= z;
    mat[8] *= x;  mat[9] *= y;  mat[10]*= z;
    mat[12]*= x;  mat[13]*= y;  mat[14]*= z;
    return mat;
  }

  mat.rightTrans = function (x, y, z) {
    mat[ 3] += mat[ 0]*x + mat[ 1]*y + mat[ 2]*z;
    mat[ 7] += mat[ 4]*x + mat[ 5]*y + mat[ 6]*z;
    mat[11] += mat[ 8]*x + mat[ 9]*y + mat[10]*z;
    mat[15] += mat[12]*x + mat[13]*y + mat[14]*z;
    return mat
  }
    
  mat.rotY = function (ang) {
    var c = cos(ang);
    var s = sin(ang);
    mat.push(...[c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]);
    return mat;
  }

  /*
   abcd   c0s0   ac+cS  b  as+cc  d
   efgh * 0100 = ec+gS  f  es+gc  h
   ijkl   S0c0   ic+kS  j  is+kc  l
   mnop   0001   mc+oS  n  ms+oc  p*/
  mat.rightRotY = function (ang) {
    var i, a, b, c = cos(ang), s = sin(ang);
    for (i=0; i<4; ++i) {
      a=mat[i*4+0];  b=mat[i*4+2];
      mat[i*4+0] =  c*a + s*b;
      mat[i*4+2] = -s*a + c*b;
    }
    return mat;
  }


  mat.rotX = function (ang) {
    var c = cos(ang);
    var s = sin(ang);
    mat.push(...[1,0,0,0, 0,c,-s,0, 0,s,c,0, 0,0,0,1]);
    return mat;
  }

  /* abcd   1000   q bc+cs  bS+cc d
     efgh * 0cS0 = e fc+gs  fS+gc h
     ijkl   0sc0   i jc+ks  jS+kc l
     mnop   0001   m nc+os  nS+oc p */
  mat.rightRotX = function (ang) {
    var i, a, b, c = cos(ang), s = sin(ang);
    for (i=0; i<4; ++i) {
      a=mat[i*4+1];  b=mat[i*4+2];
      mat[i*4+1] =  c*a + s*b;
      mat[i*4+2] = -s*a + c*b;
    }
    return mat;
  }

  mat.rotZ = function (ang) {
    var c = cos(ang);
    var s = sin(ang);
    mat.push(...[c,-s,0,0, s,c,0,0, 0,0,1,0, 0,0,0,1]);
    return mat;
  }

  /* abcd   cS00   ac+bs -as+bc c d
     efgh * sc00 = ec+fs -es+fc g h
     ijkl   0010   ic+js -is+jc k l
     mnop   0001   mc+ns -ms+nc o p */
  mat.rightRotZ = function (ang) {
    var i, a, b, c = cos(ang), s = sin(ang);
    for (i=0; i<4; ++i) {
      a=mat[i*4+0];  b=mat[i*4+1];
      mat[i*4+0] =  c*a + s*b;
      mat[i*4+1] = -s*a + c*b;
    }
    return mat;
  }

  return mat;
}

//console.log(`===============================`);
//var m = pgMatrix().dumpMat().scale(2,2,2).rightScale(3,4,5).rightTrans(2,4,6).dumpMat();
//console.log(m)



/***************************************
  Matrix_library
***************************************/
function matNewIdent () {
  return [[1, 0, 0, 0],
          [0, 1, 0, 0],
          [0, 0, 1, 0],
          [0, 0, 0, 1]];
}

function matGenRotX (a) { // PG transformation matrix
  var c = cos(a);
  var s = sin(a);
  return [0, 0,  0, 0,
          0, c, -s, 0,
          0, s,  c, 0,
          0, 0,  0, 1];
}

function matNewRotZ (a) {
  var cosa = cos(a);
  var sina = sin(a);
  return [[cosa, -sina, 0, 0],
          [sina,  cosa, 0, 0],
          [   0,     0, 1, 0],
          [   0,     0, 0, 1]];
}

function matGenTrans (x, y, z) {
  return [1, 0, 0, x,
          0, 1, 0, y,
          0, 0, 1, z,
          0, 0, 0, 1];
}
function matGenScale (x, y, z) {
  return [x, 0, 0, 0,
          0, y, 0, 0,
          0, 0, z, 0,
          0, 0, 0, 1];
}
function matNewTranslate (x, y, z) {
  return [[1, 0, 0, x],
          [0, 1, 0, y],
          [0, 0, 1, z],
          [0, 0, 0, 1]];
}

function matNewScale (x, y, z) {
  return [[x, 0, 0, 0],
          [0, y, 0, 0],
          [0, 0, z, 0],
          [0, 0, 0, 1]];
}
/*
   Mutate a transformation matrix with a post scale.

   12 multiplies
    0 additions
   12 reads
   12 writes

   abcd   x000   ax by cz d
   efgh * 0y00 = ex fy gz h
   ijkl   00z0   ix jy kz l
   mnop   0001   mx ny oz p
*/
function matAddScale (mat, x, y, z) {
  var i, row;
  for (i=0; i<4; ++i) {
    row=mat[i];
    row[0]*=x; row[1]*=y; row[2]*=z;
  }
}

/*
   Mutate a transformation matrix with a post translation.

   12 multiplies
   12 additions
   16 reads
    4 writes

   abcd   100x   a  b  c   ax+by+cz+d
   efgh * 010y = e  f  g   ex+fy+gz+h
   ijkl   001z   i  j  k   ix+jy+kz+l
   mnop   0001   m  n  o   mx+ny+oz+p
*/
function matAddTranslate (mat, x, y, z) {
  var i;
  for (i=0; i<4; ++i) {
    row=mat[i];
    row[3] +=  row[0]*x + row[1]*y + row[2]*z;
  }
  mat
}


/*
   abcd   x000   ax by cz d
   efgh * 0y00 = ex fy gz h  
   ijkl   00z0   ix jy kz l
   mnop   0001   mx ny oz p
*/
function pgMulRightScale (mat, x, y, z) {
  mat[ 0] *= x;  mat[ 1] *= y;  mat[ 2] *= z;
  mat[ 4] *= x;  mat[ 5] *= y;  mat[ 6] *= z;
  mat[ 8] *= x;  mat[ 9] *= y;  mat[10] *= z;
  mat[12] *= x;  mat[13] *= y;  mat[14] *= z;
  return mat;
}

/*
   Mutate a transformation matrix with a pre translation.

   12 multiplies
   12 additions
   12 reads
   12 writes

   100x   abcd   a+xm  b+xn  c+xo  d+xp
   010y * efgh = e+ym  f+yn  g+yo  h+yp
   001z   ijkl   i+zm  j+zn  k+zo  l+zp
   0001   mnop   m     n     o     p
*/
function matAddTranslateR (x, y, z, mat) {
  var i, row, m, n, o, p;
  row = mat[3];
  m=row[0];  n=row[1];  o=row[2];  p=row[3];

  row = mat[0];
  row[0]+=x*m;  row[1]+=x*n;  row[2]+=x*o;  row[3]+=x*p;

  row = mat[1];
  row[0]+=y*m;  row[1]+=y*n;  row[2]+=y*o;  row[3]+=y*p;

  row = mat[2];
  row[0]+=z*m;  row[1]+=z*n;  row[2]+=z*o;  row[3]+=z*p;
}

/*
   Mutate a transformation matrix with a post rotation about the Z axis

   16 multiplies
    8 additions
    8 reads
    8 writes

   x=cos(ang)  y=-sin(ang) z=sin(ang)

   abcd   xy00   ax+bz  ay+bx c d
   efgh * zx00 = ex+fz  ey+fx g h
   ijkl   0010   ix+jz  iy+jx k l
   mnop   0001   mx+nz  my+nx o p
*/
function matAddRotZ (mat, ang) {
  var i, a, b;
  var cosa = cos(ang);
  var sina = sin(ang);

  for (i=0; i<4; ++i) {
    row=mat[i];  a=row[0];  b=row[1];
    row[0] =  cosa*a + sina*b;
    row[1] = -sina*a + cosa*b;
  }
}

/*
   Mutate a transformation matrix with a pre rotation about the Z axis

   16 multiplies
    8 additions
    8 reads
    8 writes

   x=cos(ang)  y=-sin(ang) z=sin(ang)

   xy00   abcd   xa+ye  xb+yf  xc+yg  xd+yh
   zx00 * efgh = za+xe  zb+xf  zc+xg  zd+xh
   0010   ijkl       i      j      k      l
   0001   mnop       m      n      o      p
*/
function matAddRotZR (ang, mat) {
  var row0, row1, a, b, c, d, e, f, g, h;
  var cosa = cos(ang);
  var sina = sin(ang);
  row0 = mat[0];
  row1 = mat[1];

  a=row0[0];  b=row0[1];  c=row0[2];  d=row0[3];
  e=row1[0];  f=row1[1];  g=row1[2];  h=row1[3];

  row0[0] = cosa*a + -sina*e;
  row0[1] = cosa*b + -sina*f;
  row0[2] = cosa*c + -sina*g;
  row0[3] = cosa*d + -sina*h;

  row1[0] = sina*a + cosa*e;
  row1[1] = sina*b + cosa*f;
  row1[2] = sina*c + cosa*g;
  row1[3] = sina*d + cosa*h;
}


/*
   Mutate a transformation matrix with a post rotation about the X axis

   16 multiplies
    8 additions
    8 reads
    8 writes

   x=cos(ang)  y=-sin(ang) z=sin(ang)

   abcd   1000   a  bx+cz  by+cx  d
   efgh * 0xy0 = e  fx+gz  fy+gx  h
   ijkl   0zx0   i  jx+kz  jy+kx  l
   mnop   0001   m  ox+oz  ny+ox  p
*/
function matAddRotX (mat, ang) {
  var i, a, b;
  var cosa = cos(ang);
  var sina = sin(ang);

  for (i=0; i<4; ++i) {
    row=mat[i];  a=row[1];  b=row[2];
    row[1] =  cosa*a + sina*b;
    row[2] = -sina*a + cosa*b;
  }
}

function matAddPerspective (mat, per) {
/*
  abcd            [x   [(x*per)/y
  efgh *   ?   *   y    y
  ijkl             z    (z*per)/y
  mnop             1]   ?]
*/
  for (i=0; i<vectors.length; ++i) { // Over every vector
    var v = vectors[i]; // Consider vector
    var x = v[0];
    var y = v[1];
    var z = v[2];
    var p = per / y;
    v[0] = x * p;
    v[2] = z * p;
  }
}

/*
  Pre-multiply mutate a column-major matrix of vectors by a row-major transformation matrix

   N*16     multiplies
   N*12     additions
   N*4 + 16 reads
   N*4      writes

 [[a b c d]     [[x         [[ax+by+cz+dw
  [e f g h]   *   y  ...  =   ex+fy+gz+hw  ...
  [i j k l]       z           ix+jy+kz+lw
  [m n o p]]      w]    ]     mx+ny+oz+pw]     ]

  row-major    column-major
*/
function matMultMatVecs (mat, vecs) {
  var mat0=mat[0], mat1=mat[1], mat2=mat[2], mat3=mat[3];
  var a=mat0[0], b=mat0[1], c=mat0[2], d=mat0[3];
  var e=mat1[0], f=mat1[1], g=mat1[2], h=mat1[3];
  var i=mat2[0], j=mat2[1], k=mat2[2], l=mat2[3];
  var m=mat3[0], n=mat3[1], o=mat3[2], p=mat3[3];

  var i, vec, x, y, z, w, ww, normalized;

  for (ii=0; ii<vecs.length; ++ii) {
     normalized=true;
     // Consider a vector in the list
     vec = vecs[ii];
     x = vec[0];
     y = vec[1];
     z = vec[2];
     w = vec[3];
     if (undefined == w) { normalized=false;  w=1; }

     ww       = x*m + y*n + z*o + w*p;
     vec[0]   = (x*a + y*b + z*c + w*d)/ww;
     vec[1]   = (x*e + y*f + z*g + w*h)/ww;
     vec[2]   = (x*i + y*j + z*k + w*l)/ww;
     if (normalized) {
       vec[3] = 1;
     }
  }
}

/* Left multiply a transformation matrix with a list of vectors.  Both are linear arrays.
   [a b c d    [x x2
    e f g h     y y2
    i j k l   * z z2 ...]
    m n o p]
*/
function matMul4Mat3VecLinear (mat, vec) {
  var q=0;
  var a=mat[q++], b=mat[q++], c=mat[q++], d=mat[q++];
  var e=mat[q++], f=mat[q++], g=mat[q++], h=mat[q++];
  var i=mat[q++], j=mat[q++], k=mat[q++], l=mat[q++];
  var m=mat[q++], n=mat[q++], o=mat[q++], p=mat[q++];
  var x, y, z, w, res=Array(vec.length/3*4);


  for (r=0; r<vec.length; r+=3) {
     x = vec[r];
     y = vec[r+1];
     z = vec[r+2];
     // w = 1
     res[r/3*4+0] = (x*a + y*b + z*c + d);
     res[r/3*4+1] = (x*e + y*f + z*g + h);
     res[r/3*4+2] = (x*i + y*j + z*k + l);
     res[r/3*4+3] = (x*m + y*n + z*o + p);
  }
  return res;
};

/*
             [[a b c d]    [[A B C D]
 y = x * y =  [e f g h]  *   E F G H]
              [i j k l]      I J K L]
              [m n o p]]     M N O P]]
*/
function pgMultXformXformNew (x, y) {

  var a=x[0], b=x[1], c=x[2], d=x[3];
  var e=x[4], f=x[5], g=x[6], h=x[7];
  var i=x[8], j=x[9], k=x[10], l=x[11];
  var m=x[12], n=x[13], o=x[14], p=x[15];

  var A=y[0], B=y[1], C=y[2], D=y[3];
  var E=y[4], F=y[5], G=y[6], H=y[7];
  var I=y[8], J=y[9], K=y[10], L=y[11];
  var M=y[12], N=y[13], O=y[14], P=y[15];

  var z=Array(16);
  z[0] = a*A + b*E + c*I + d*M;
  z[1] = a*B + b*F + c*J + d*N;
  z[2] = a*C + b*G + c*K + d*O;
  z[3] = a*D + b*H + c*L + d*P;

  z[4] = e*A + f*E + g*I + h*M;
  z[5] = e*B + f*F + g*J + h*N;
  z[6] = e*C + f*G + g*K + h*O;
  z[7] = e*D + f*H + g*L + h*P;

  z[8] = i*A + j*E + k*I + l*M;
  z[9] = i*B + j*F + k*J + l*N;
  z[10] = i*C + j*G + k*K + l*O;
  z[11] = i*D + j*H + k*L + l*P;

  z[12] = m*A + n*E + o*I + p*M;
  z[13] = m*B + n*F + o*J + p*N;
  z[14] = m*C + n*G + o*K + p*O;
  z[15] = m*D + n*H + o*L + p*P;

  return z;
}

function matMultMatMat (x, y) {
  var row;

  row = x[0]; var a=row[0], b=row[1], c=row[2], d=row[3];
  row = x[1]; var e=row[0], f=row[1], g=row[2], h=row[3];
  row = x[2]; var i=row[0], j=row[1], k=row[2], l=row[3];
  row = x[3]; var m=row[0], n=row[1], o=row[2], p=row[3];

  row = y[0]; var A=row[0], B=row[1], C=row[2], D=row[3];
  row = y[1]; var E=row[0], F=row[1], G=row[2], H=row[3];
  row = y[2]; var I=row[0], J=row[1], K=row[2], L=row[3];
  row = y[3]; var M=row[0], N=row[1], O=row[2], P=row[3];

  row = y[0];
  row[0] = a*A + b*E + c*I + d*M;
  row[1] = a*B + b*F + c*J + d*N;
  row[2] = a*C + b*G + c*K + d*O;
  row[3] = a*D + b*H + c*L + d*P;

  row = y[1];
  row[0] = e*A + f*E + g*I + h*M;
  row[1] = e*B + f*F + g*J + h*N;
  row[2] = e*C + f*G + g*K + h*O;
  row[3] = e*D + f*H + g*L + h*P;

  row = y[2];
  row[0] = i*A + j*E + k*I + l*M;
  row[1] = i*B + j*F + k*J + l*N;
  row[2] = i*C + j*G + k*K + l*O;
  row[3] = i*D + j*H + k*L + l*P;

  row = y[3];
  row[0] = m*A + n*E + o*I + p*M;
  row[1] = m*B + n*F + o*J + p*N;
  row[2] = m*C + n*G + o*K + p*O;
  row[3] = m*D + n*H + o*L + p*P;
}
/*** TEST **********************************************************************
  Multiply identiy matrix a with b, mutating b.
*/
(function TESTmatMultMatMat () {
  var a =
   [[1, 0, 0, 0],
    [0, 1, 0, 0],
    [0, 0, 1, 0],
    [0, 0, 0, 1]];
  var b =
   [[1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
    [13, 14, 15, 16]];

  matMultMatMat(a,b);

  TESTCmpAryAry(b,
   [[1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
    [13, 14, 15, 16]]);
  console.log("PASS TESTmatMultMatMat");

})();
//******************************************************************************




/***************************************
  The_map representing the playing field.  Origin
  is bottom left of this array = map[0][0].  Convert an array of
  strings to a grid of numbers.
***************************************/
var cmap = [
  "| |                                                          | |",
  " T                                                            T ",
  "| |                                                          | |",
  "                               g                                ",
  "                                                                ",
  "                               g                                ",
  "                                                                ",
  "                               g                                ",
  "                                                                ",
  "                               g                                ",
  "                                                                ",
  "                               g                                ",
  "                                                                ",
  "                               g                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ",//
  " /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /  ",
  "   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /   /",
  "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ",//
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                           g g g g g                            ",
  "                            g g g g                             ",
  "                             g g g                              ",
  "                              g g                               ",
  "                               g                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                                                                ",
  "                              xxx                            | |",
  " T                            xpx                             T ",
  "                              xsx                            | |"
].reverse();

var mapHeight = cmap.length;
var mapWidth  = cmap[0].length
var map=[];

for (var y=0; y<mapHeight; ++y) {
  map[y] = [];
  for (var x=0; x<mapWidth; ++x) {
    var c=0;
    if (cmap[y].charAt(x) == " ") c = rnd(8) ? 1 : 2;
    else if (cmap[y].charAt(x) == "x") c = 3;
    else if (cmap[y].charAt(x) == "s") c = 4;
    else if (cmap[y].charAt(x) == "g") c = 5;
    else if (cmap[y].charAt(x) == "T") c = 6;
    else if (cmap[y].charAt(x) == "p") c = 7; // player
    else if (cmap[y].charAt(x) == "/") c = 8;
    else if (cmap[y].charAt(x) == "|") c = 9;
    map[y][x] = c;
  }
}

var mapWithin = function (x, y) { return (0<=x) && (x<mapWidth) && (0<=y) && (y<mapHeight); }
var mapIsSolid = function (x, y) { return false && mapWithin(x,y) && 5 != map[y|0][x|0] && 3 != map[y|0][x|0]; }
var mapIsPill  = function (x, y) { return mapWithin(x,y) && 1 == map[y|0][x|0]; }


/***************************************
  Globals
***************************************/
var last = {};
var rem = {};
var mouseLookX = PI0;
var mouseLookY = PI0;


/***************************************
  Main
***************************************/
function Main () {
  DB("::JavaScriptArtilleryClientV3.0.d");
  var canvas = document.getElementsByTagName('canvas')[0];
  var context = canvas.getContext('2d');
  var parentStyle = window.getComputedStyle(canvas.parentElement); // Adjust canvas size to parent's size
  var width = canvas.width = document.body.clientWidth; //parseInt(parentStyle.getPropertyValue("width"));
  var height = canvas.height = document.body.clientHeight;; //parseInt(parentStyle.getPropertyValue("height"));
  var lscale = 1; // Scale all object coordinates by this
  var quit = false;
  var hud = true;
  var gas = [0,0,0,0]; // Literally the gas pedal in the North South East West directions
  var jumping = 0;
  var mouseActive = false;
  var mouseRotX=0, mouseRotY=0;
  var elevation = .2;
  var collision = false;
  var score=0;
  var scene = []; // Simple array of renderable object groups.
  var frameRateTime=getTime();
  var frameCount=0;
  var frameRate=0;
  var cannons = [];
  var ghostGroups=[];
  var ghostEntities=[];

  context.translate(width/2, height/2); // Set canvas's origin to center
  function quitToggle () { DB("QUIT"); quit ^= 1; }
  function hudToggle () { hud ^= 1; }
  //function gasToggle () { gas = (0 <= gas) ? -1 : 0; }
  function gasWalkNorth(v) { gas[0] = v; }
  function gasWalkSouth(v) { gas[1] = v; }
  function gasWalkEast(v)  { gas[2] = v; }
  function gasWalkWest(v)  { gas[3] = v; }
  function heightAdd (x) { elevation += x;  /*if (elevation < 0) elevation = 0;*/ if (400 < 400) elevation = 400; }
  function jump () {
    if (jumping) return;
    jumping = 1;
    cannons.push(Body(Trajectory(pacman, 15, PI80, 60))); // grav ang vel
  } // Reset next parameterized shell motion at current time.

  function fire () {
        // Create the new bullet at the location of the user's avatar.
        var g = scaleGroupVerticesOriginal(groupInitialize(pspec_pacman), 0.1, 0.1, 0.1);
        g.label = "bullet";
        //DB(pacman.locam.x + " " + pacman.locam.y + " " + pacman.locam.z);
        g.transformBase = matNewTranslate(pacman.locam.x, pacman.locam.y, pacman.locam.z);
        scene.push(g);
        var e = new Entity("bullet", [pacman.locam.x, pacman.locam.y, pacman.locam.z], mouseLookX);
        e.group = g;
        cannons.push(Body(Trajectory(e, 2, PI10, 20))); // WAS -mouseLoookY loc dir grav ang vel
        if (socket.readState == socket.OPEN) { socket.send("fire"); }
  }

  /* Clear the canvas with all black
  */
  function clearContext () {
    var width = canvas.width;
    var height = canvas.height;
    if (collision) {
      context.fillStyle = "red";
      context.fillRect(-width/2,-height/2,width, height);
    } else if (false) {
      // Solid sky
      context.fillStyle = "#080008";
      context.fillRect(-width/2, -height/2, width, height/2);
      //var offset = 2*1013*pacman.diram/8;
      var offset = 2*1013*(mouseLookX%360)/360.0;
      // Bitmap sky
      context.drawImage(starsr, canvas.width/2 - offset + 3*1013, -stars.height)
      context.drawImage(stars,  canvas.width/2 - offset + 2*1013, -stars.height)
      context.drawImage(starsr, canvas.width/2 - offset + 1013, -stars.height)
      context.drawImage(stars,  canvas.width/2 - offset       , -stars.height)
      context.drawImage(starsr, canvas.width/2 - offset - 1013, -stars.height)
      context.drawImage(stars,  canvas.width/2 - offset - 2*1013, -stars.height)
      context.drawImage(starsr, canvas.width/2 - offset - 3*1013, -stars.height)
      context.drawImage(stars,  canvas.width/2 - offset - 4*1013, -stars.height)
      // Solid ground
      context.fillStyle = "#020";
      context.fillRect(-width/2, 0, width, height);
    } else {
      context.fillStyle = "black";
      context.fillRect(-width/2,-height/2,width, height);
    }
  }

  /* Create all objects that make up scene (the maze) and set their starting positions
  */
  for (var y=0; (y < map.length); ++y) {
    for (var x=0; (x < map[0].length); ++x) {
      var grp;
      switch (map[y][x]) {
        case 1 : {
          scene.push(pcGen("floor", pcsGenFloor()).setXform(pgMatrix().trans(x,y,0)))
          break;
        }
        case 2 : {
          scene.push(pcGen("floor", pcsGenFloor()).setXform(pgMatrix().trans(x,y,0)))
          pc = pcGen("gravel", pcsGenCubeRGB())
               .setXform(pgMatrix().trans(x,y,0).rightScale(.5).rightTrans(0,0,.5))
               .setAni( (pc, state) => pc.rightMulXform(pgMatrix().rotZ(state.time/1000)) );
          scene.push(pc);
          break;
        }
        case 3 : { // road
          scene.push(pcGen("floor", pcsGenFloor(0.5, "800f", "f00f"))
                     .setXform(pgMatrix().trans(x,y,0)))
          break;
        }
        case 4 : { // special case for car
          var g = scaleGroupVerticesOriginal(groupInitialize(pspec_pacman), .5, .5, .5);
          g.transformBase = matNewIdent();
          scene.push(g);
          pacman = new Entity("pacman", [x, y, 0.5], 2);
          pacman.group = g;
          break;
        }
        case 5 : { // special case for ghost
          var gg = scaleGroupVerticesOriginal(groupInitialize(pspec_ghost), 1.0, 1.0, 1.0);
          ghostGroups.push(gg);
          rotateZ(gg.verticesBase, PI180);
          scene.push(gg);
          var ge = new Entity("ghost", [x, y, 0.5], 4);
          ghostEntities.push(ge);
          ge.mode = 1;
          break;
        }
        case 6 : {
          scene.push(pcGen("iotower", pcsGenPyramidSolid(0.5, "f00f", "800f")).setXform(pgMatrix().trans(x,y,0).rightScale(1,1,100)));
          break;
        }
        case 7 : { // turrent (the player AKA pacman AKA the cannon/turret)
          var g = groupInitialize(pspec_pacman);
          g.transformBase = matNewIdent();
          matAddTranslate(g.transformBase, lscale*x, lscale*y, .1);
          g.label="turret";
          scene.push(g);
          break;
        }
        case 8 : {
          scene.push(pcGen("maze", pcsGenCubeRainbow()).setXform(pgMatrix().trans(x,y,0).rightScale(1,1,9).rightTrans(0,0,.5)));
          break;
        }
        case 9 : { // outer wall
          pc = pcGen("wall", pcsGenCubeSolid()).setXform(pgMatrix().trans(x,y,0).rightScale(1,1,5).rightTrans(0,0,.5));
          scene.push(pc);
          break;
        }
      } // switch
    } // for x
  } // for y


  /* A perimeter of towers
  */
  for (var a=0; a<5000; a+=8) {
    var m = matNewIdent();
    //matAddRotY(m, (Math.pow(2.0,25+rnd(6000)/1000.0)/23000000)*PI1);
    scene.push(pcGen("dome", pcsGenCubeRainbow()).setXform(pgMatrix().rotZ(a*PI1).rightRotX(a*PI1/90).rightTrans(0, 100, 0).rightScale(5,5,5)));
  }

  /* Zoom/scale is adjustable
  */
  var zoom=400.0
  function slowZoom (m) {
    DB.post("zoom", zoom);
    if (.0001 < abs(m)) {
      if (m < 0) {
        zoom -= .05;
        //mainRenderLoop();
        setTimeout(function(){slowZoom(m + .1)}, 1);
      } else if (0 < m) {
        zoom += .05;
        //mainRenderLoop();
        setTimeout(function(){slowZoom(m - .1)}, 1);
      }
    }
  }

  /* Render Loop -- All the animation occurs in this block
  */
  function mainRenderLoop () {
    var clear = 1;
    var currentTime = getTime();
    var currentState = {time:currentTime};
    var sortedVisibleScene=[];

    /* Tick pacman
    */
    //if (gas) { pacman.tick(currentTime); }
    if (gas[0] || gas[1] || gas[2] || gas[3]) {
      pacman.tickInDirection(
        mouseLookX
         + [[PI315,PI0,PI45],[PI270,PI0,PI90],[PI225,PI180,PI135]][gas[0]-gas[1]+1][gas[2]-gas[3]+1], .2); // magnitude
      //DB.post("mouse", pacman.diram.toFixed(2) + " " + pacman.locam.x.toFixed(2) + " " + pacman.locam.y.toFixed(2) + " " + pacman.locam.z.toFixed(2));
    }

    /* Tick cannons
    */
    //DB.post("cannons length", cannons.length)
    cannons.forEach( (body,idx)=>{
      if (null != body) {
        var loc = body.tick(currentTime);
        //DB.post("body", loc.x + " " + loc.y + " " + loc.z);
        var entity = body.entity;
        var group = entity.group;
        //console.log(loc);
        if (entity.label == "pacman") {
          if (loc.z < 0.5) {
            jumping = 0;
            cannons[idx] = null;
            entity.locam.x = loc.x;
            entity.locam.y = loc.y;
            entity.locam.z = 0.5;
          } else {
            entity.locam.x = loc.x;
            entity.locam.y = loc.y;
            entity.locam.z = loc.z;
          }
        } else {
          if (loc.z < 0.0) {
            group.transformBase = matNewTranslate(loc.x, loc.y, 0.0);
            cannons[idx] = null;
           } else {
            group.transformBase = matNewTranslate(loc.x, loc.y, loc.z);
          }
        }
      }
    });

    /* Tick ghosts
    */
    collision = false;

    for (var i=0; i<ghostGroups.length; ++i) {
      var gg = ghostGroups[i];
      var ge = ghostEntities[i];
      ge.tick(currentTime);
      gg.transformBase = matNewIdent();
      matAddTranslate (gg.transformBase, lscale*ge.locam.x, lscale*ge.locam.y, 0);
      matAddRotZ(gg.transformBase, (ge.diram)/8 * PI360);
      // Detect collision between this ghost and pacman
      collision = collision || (distLocLoc(pacman.locam, ge.locam) < 0.5)
    }

    // Camera transformations.  In reverse order since-left multiplied Mat*[vercies]
    var matScene = matNewIdent()
    matAddRotX(matScene, mouseLookY);
    matAddRotZ(matScene, mouseLookX);
    matAddTranslate(matScene, -pacman.locam.x*lscale, -pacman.locam.y*lscale, -pacman.locam.z*lscale-elevation);

    // PG scene transformation matrix NEW
    pgMatScene = pgMatrix()
                 .rotX(mouseLookY)
                 .rightRotZ(mouseLookX)
                 .rightTrans(-pacman.locam.x*lscale,
                             -pacman.locam.y*lscale,
                             -pacman.locam.z*lscale-elevation);

    /* Create a new transformation matrix for every group in scene based on a copy
       of the base transformation matrix.  Apply the resulting transform on each
       object's center vertex to determine potential visibility and keep track of
       visible in a new array.
    */
    for (var g=0; g<scene.length; ++g) {
      var group = scene[g]    // Old polyon group
      var xform = null;

      var pg;                 // New PG object

      var label = group.label; // Both share this attribute.

      if (group.pg) { // NEW scene object is a PCS group.
        pg = group.reset();
        pg.tick(currentState);
        group = null;
      }

      // Individual transform to apply to current object
      if (group) {
        var xform = group.transformBase;
        if (false !== xform) xform = copyAryAry(xform);
      }

      /* Transforms and triggers for dynamic objects
      */
      if (label == "pill") {
        var y=pacman.locfr.y,
            x=pacman.locfr.x;
        if (eqpair(pacman.locfr,  pacman.locam) // New tock cycle
            && mapIsPill(x, y)
            && x == group.transformBase[0][3]/2
            && y == group.transformBase[1][3]/2) {
          map[y][x] = 1.1;
          doScore(group, 1);
        }
        matAddRotZ(xform, currentTime/4000);
        matAddRotX(xform, currentTime/300);
      }
      else if (label == "power") {
        var y=pacman.locfr.y,
            x=pacman.locfr.x;
        if (eqpair(pacman.locfr,  pacman.locam) // New tock cycle
            && mapWithin(x,y)
            && map[y][x]==2
            && x == group.transformBase[0][3]/2
            && y == group.transformBase[1][3]/2) {
          map[y][x] = 1.1;
          doScore(group, 100);
        }
        matAddScale(xform, 2+.2*sin(currentTime/200), 2+.2*sin(currentTime/220), 2+.2*sin(currentTime/230));
      }
      else if (label == "ghost") {
        //matAddTranslate (xform, 0, 0, .1+.1*sin(currentTime/200));
      }
      else if (label == "pacman") {
        matAddTranslate (xform, lscale*pacman.locam.x, lscale*pacman.locam.y, lscale*pacman.locam.z);
        matAddRotZ(xform, (pacman.diram)/8 * PI360);
      }
      else if (label == "turret") {
        //matAddRotY(xform, mouseLookX/100.0);
        //matAddRotX(xform, mouseLookY/100.0);
        xform = matNewRotZ(rem.d);
        matAddTranslateR(rem.x/2, rem.y/2, 0, xform);
      } else if (label == "gravel") {
      } else if (label == "dome") {
          //matAddRotX(xform, currentTime/10*PI1);
          //matAddRotY(xform, currentTime/10*PI1);
          //matAddRotZR(currentTime/20*PI1, xform);
      } else if (label == "maze") {
        //var j = group.verticesBase[0][0];
        //xform = matNewScale(1.0, 1.0, 1.0+sin((j/10+currentTime/1000)*PI90));
      } else if (label == "wall") {
        //var j = group.verticesBase[0][0];
        //xform = matNewScale(1.0, 1.0, 1.0+sin((-j/5+currentTime/1000)*PI90));
      }

      if (group) {
        if (xform) {
          // Combine the individual transform with the camera's transform
          matMultMatMat(matScene, xform);
          group.transform = xform;
        } else {
          // Static object just gets the camera transform
          group.transform = matScene;
        }
      } else {
        pg.leftMulXform(pgMatScene).rightMulXform(xform); // Apply camera transform to the initial pg object.
      }

      // Transform just the center vertex for now
      if (group) {
        groupTransformMatVertexCenter(group.transform, group);
      } else {
        pg.xformCenter();
      }

      // Keep track of the groups whos center is in front of camera
      if (group) {
        if (!perspective(group.vertexCenter, 400)) sortedVisibleScene.push(group);
      } else {
        if (!pgPerspective(pg.getCenter(), 400)) {
          sortedVisibleScene.push(pg);
       }
      }

    } // for scene.length

    /* Sort the new group of potentially visible groups
    */
    myz = sortedVisibleScene;
    sortedVisibleScene.sort(function (a,b) {
      if (a.pg && b.pg) {
        return b.getCenter()[1] - a.getCenter()[1];
      } else if (a.pg) {
        return b.vertexCenter[0][1] - a.getCenter()[1];
      } else if (b.pg) {
        return b.getCenter()[1] - a.vertexCenter[0][1];
      } else {
        return b.vertexCenter[0][1] - a.vertexCenter[0][1];
      }
    });

    /* Transform and plot each object
    */
     for (var g=0; g < sortedVisibleScene.length; ++g) {
       var group = sortedVisibleScene[g];

       if (group.pg) {
         pg = group;
         group = null;
       }

       if (group && group.invisible) continue;

       if (group) {
         groupTransformMatVerticesOriginal(group.transform, group);
       } else {
         pg.xformPoints()
         //pg.dump();
       }

       if (group) {
         if (perspective(group.vertices, 400)) continue;
       } else {
         if (pgPerspective(pg.getPoints(), 400)) continue;
       }

       // Need to stretch along y-axis so normal calculations are more sane
       if (group) {
         scale(group.vertices, 1, 50, 1);
       } else {
         //pgScale(pg.getPoints(), 1, 50, 1);
       }

       if (group) for (var f=0; f<group.faces.length; ++f) {
         var gvertices = group.vertices;
         var face = group.faces[f];
         var indices = face.indices;
         var gv0 = gvertices[indices[0]]; // Consider first three vector for normal calculations
         var gv1 = gvertices[indices[1]];
         var gv2 = gvertices[indices[2]];
         var theNormal = getNormal(gv2, gv1, gv0);
         var v;

         if (theNormal[1] > 0) {
           // Begin drawing the initial and next two cached points (x, z)
           context.beginPath();
           context.moveTo(gv0[0], -gv0[2]);
           context.lineTo(gv1[0], -gv1[2]);
           context.lineTo(gv2[0], -gv2[2]);

           // Draw the rest of the points
           for (var i=3; i<indices.length; ++i) {
             v = gvertices[indices[i]];
             context.lineTo(v[0], -v[2]);
           }

           // Render filled area
           var nx = theNormal[0];
           var ny = theNormal[1];
           var nz = theNormal[2];
           var r = Math.sqrt(nz*nz + ny*ny + nx*nx);
           // Normalize the normal
           //nz = nz / r;
           ny = ny / r;
           //nx = nx / r;

           var fillStyle = "rgba(" + ((ny * face.colorFill.r) | 0) + "," + // x.round == x|0
                                     ((ny * face.colorFill.g) | 0) + "," +
                                     ((ny * face.colorFill.b) | 0) + "," +
                                     (face.colorFill.a) + ")";

           // Clear view port before the first polygon is rendered to avoid flickering
           if (clear) { clearContext();  clear = 0; }

           context.fillStyle = fillStyle;
           context.fill();

           // Outline the faces

           context.closePath();
           context.strokeStyle = face.colorEdgeStr;
           context.lineWidth = "1"; // Adjust outline width thicker when closer to camera.
           context.stroke();

         } // if theNormal > 0
       } // for faces.group.length
       else {
         var faces = pg.getFaces();
         var points = pg.getPoints();
         for (var f=0; f<faces.length; ++f) {
           var face = faces[f];
           var indices = face.face;
           var i0 = indices[0]*4;
           var i1 = indices[1]*4;
           var i2 = indices[2]*4;

           var v0 = points.slice(i0,i0+3)
           var v1 = points.slice(i1,i1+3)
           var v2 = points.slice(i2,i2+3)

           if (getNormal(v2, v1, v0)[1] <=0) { continue; }

           context.beginPath()
           context.moveTo(v0[0], -v0[2]);
           context.lineTo(v1[0], -v1[2]);
           context.lineTo(v2[0], -v2[2]);

           // Draw the rest of the points
           for (var i=3; i<indices.length; ++i) {
             i0 = indices[i]*4;
             v0 = points.slice(i0,i0+3);
             context.lineTo(v0[0], -v0[2]);
           }

           var ny=1;
           var fillStyle = "rgba(" + ((ny * face.fill.r) | 0) + "," + // x.round == x|0
                                     ((ny * face.fill.g) | 0) + "," +
                                     ((ny * face.fill.b) | 0) + "," +
                                     (face.fill.a) + ")";

           if (clear) { clearContext();  clear = 0; }

           context.fillStyle = fillStyle;
           context.fill();

           // Outline the faces

           context.closePath();
           context.strokeStyle = face.edgeStr;
           context.lineWidth = "1"; // Adjust outline width thicker when closer to camera.
           context.stroke();

         }
       }
     } // for sortedVisibleScene.length

    // Frame rate
    ++frameCount;
    if (frameRateTime+1000 <= currentTime) {
      frameRate = 1000*frameCount/(currentTime - frameRateTime);
      frameRateTime = getTime();
      frameCount=0;
    }

    if (hud) {
      context.fillStyle = "rgba(0,255,0,1)";
      context.textAlign = "right";
      context.textBaseline = "top";
      context.font = "bold 16px Arial";
      context.fillText(frameRate.toFixed(1), width/2, -height/2);
      //DB.post("Rate", frameRate.toFixed(2));
      //context.fillText("fr   "+pacman.dirfr.toFixed(2) + "(" + pacman.locfr.x.toFixed(2) + " " + pacman.locfr.y.toFixed(2) + ")", -width/2, -height/2+30);
      //context.fillText("am "+pacman.diram.toFixed(2) + "(" + pacman.locam.x.toFixed(2) + " " + pacman.locam.y.toFixed(2) + ")", -width/2, -height/2+60);
      //context.fillText("be  "+pacman.dirbe.toFixed(2) + " (" + pacman.locbe.x.toFixed(2) + " " + pacman.locbe.y.toFixed(2) + ")", -width/2, -height/2+90);
      //context.fillText("go  "+pacman.dirgo,-width/2, -height/2+120);
    }

    // BF: TODO
    // Update server of my wareabouts.
    if (socket.readyState && (last.d != mouseLookX || last.x != pacman.locam.x || last.y != pacman.locam.y)) {
        //var b = Uint8Array.alloc(1+1+8+8+8);
        last.d = mouseLookX;
        last.x = pacman.locam.x;
        last.y = pacman.locam.y;

        var buff = new ArrayBuffer(14);
        var db = new DataView(buff);
        db.setUint8(0, 1); // 1 is move
        db.setUint8(1, 2); // this will be the id
        db.setFloat32(2, last.d);
        db.setFloat32(6, last.x);
        db.setFloat32(10, last.y);
        //DB("sending" + buff.byteLength + " bytes.");
        if (socket.readState == socket.OPEN) { socket.send(buff); }
    }


    if (!quit) setTimeout(function(){mainRenderLoop()}, 10);
    else DB ("done.");

  } // mainRenderLoop()

  var doScore = function (group, pts) {
    var pill = new Entity("pill", [0, 0, 0], 0);
    pill.locticker.reset(getTime(), 5000);
    pill.locbe.z += 5;

    scores.add(score+=pts);

    // Slowly scale the group down to nothingness then set invisible.
    var pillthread = function () {
      pill.tick(getTime());
      lgz = pill.locam.z;
      //matAddTranslate(group.transformBase, 0, 0, 2);
      //group.transformBase[2][3] = lgz;
      matAddScale(group.transformBase, .92, .92, .92);
      if (pill.locam.z != pill.locbe.z) {
        setTimeout(function(){pillthread()}, 100);
      } else {
        group.invisible = true;
      }
    }
    pillthread();
  }

/*
  var globalMouse = false;
  window.onmousedown = function (event) {
    globalMouse = event.which;
    // Mouse click on screen will move the mouse as well
    pacman.turnByDelta(
      event.clientX < width/3   ? 2 :
      width*2/3 < event.clientX ? 6 : 4);
  }

  window.onmouseup = function () { globalMouse = false; }
*/

  // Rotate scene based on mouse movement event
  //window.mycanvas.onmousemove = function () {
  //  if (mouseActive && globalMouse == 1) {
  //    var x = event.clientX;
  //    var y = event.clientY;
  //    mouseRotX = (x-width/2)/99;
  //    mouseRotY = (height/2-y)/99;
  //  }
  //}

  var flagShift = false;

  var Button_shift = 16;
  var Button_esc = 27;
  var Button_left = 37;
  var Button_up = 38;
  var Button_right = 39;
  var Button_down = 40;
  var Button_minus = 189;
  var Button_equals = 187
  var Button_a = 'A'.charCodeAt();
  var Button_d = 'D'.charCodeAt();
  var Button_f = 'F'.charCodeAt();
  var Button_g = 'G'.charCodeAt();
  var Button_h = 'H'.charCodeAt();
  var Button_i = 'I'.charCodeAt();
  var Button_j = 'J'.charCodeAt();
  var Button_k = 'K'.charCodeAt();
  var Button_l = 'L'.charCodeAt();
  var Button_q = 'Q'.charCodeAt();
  var Button_s = 'S'.charCodeAt();
  var Button_m = 'M'.charCodeAt();
  var Button_space = ' '.charCodeAt();
  var Button_bracketOpen = 219;
  var Button_bracketClose = 221;

  document.body.onkeyup = function () {
    var b = event.keyCode;
    switch (b) {
      case Button_shift : flagShift=false; DB("shift="+flagShift); break;
    }
  };

  document.body.ontouchmove = function (e) {
      DB( e.changedTouches[0].pageX);
      mouseLookX = e.changedTouches[0].pageX * PI1;
      mouseLookY = e.changedTouches[0].pageY * PI1;
      if (mouseLookY < -PI45) mouseLookY = -PI45;
      if (PI45 < mouseLookY) mouseLookY = PI45;
  };


  function mouseControlsLook () {
    document.body.onmousemove = (e) => {
      mouseLookX += e.movementX * PI1;
      mouseLookY += e.movementY * PI1;
      if (mouseLookY < -PI90) mouseLookY = -PI90;
      if (PI90 < mouseLookY) mouseLookY = PI90;
    }
  };


  var enterPointerLock = function () {
    mouseControlsLook();
    document.body.onclick = function (e) {
      if (e.button == 0) { fire(); }
      if (e.button == 2) { jump(); }
    }
    //gas = 1; // Start motion
  }

  var exitPointerLock = function () {
    document.body.onmousemove = null;
    document.body.onclick = null;
    //gas = -1;
  };

  /* Locked mouse pointer state machine. The exit-pointer-lock state
     is entered at the start.
  */
  ((locked=1) =>
   document.onpointerlockchange = () => {
     if (locked ^= 1) {
       enterPointerLock();
     } else {
       exitPointerLock();
       document.body.onclick = document.body.requestPointerLock;
     }
   })()();

  setTimeout( mouseControlsLook, 1000);


  document.body.onkeydown = function (event) {
    var b = event.keyCode;
    //DB.post("key"+b, "down");
    switch (b) {
      case Button_shift : flagShift=true; break;
      //case Button_i : if (flagShift) { pacman.walkInDirection(0); break; }
      //case Button_up :    pacman.turnByDelta(0); break;
      //case Button_k : if (flagShift) { pacman.walkInDirection(4); break; }
      //case Button_down :  pacman.turnByDelta(4); break;
      //case Button_j : if (flagShift) { pacman.walkInDirection(2); break; }
      //case Button_left:   pacman.turnByDelta(.2); break;
      //case Button_l : if (flagShift) { pacman.walkInDirection(6); break; }
      //case Button_right : pacman.turnByDelta(7.8); break;
      //case Button_g :     gasToggle(); break;
      case Button_h :     hudToggle(); break;
      case Button_space : jump(); break;
      case Button_q :     quitToggle(); break;
      case Button_down :
      case Button_a :     gasWalkNorth(1); break;
      case Button_up:
      case Button_s :     gasWalkSouth(1); break;
      case Button_right :
      case Button_f :     gasWalkEast(1);  break;
      case Button_left :
      case Button_d :     gasWalkWest(1); break;
      case Button_equals :  heightAdd(1); break;
      case Button_minus : heightAdd(-1); break;
      case Button_bracketOpen : slowZoom(-100); break;
      case Button_bracketClose : slowZoom(100); break;
      case Button_m : mouseActive = !mouseActive;
    }
  }

  document.body.onkeyup = function (event) {
    var b = event.keyCode
    //DB.post("key"+b, "up");
    switch (b) {
      case Button_down :
      case Button_a : gasWalkNorth(0); break;
      case Button_up :
      case Button_s : gasWalkSouth(0); break;
      case Button_right :
      case Button_f : gasWalkEast(0); break;
      case Button_left:
      case Button_d : gasWalkWest(0); break;
    }
  }

  mainRenderLoop();
} // Main



window.onload = function () { Main(); }
var socket = new WebSocket('ws://world.dv8.org:7199')
socket.binaryType = "arraybuffer";

socket.onopen = function (event) {
  DB("websocket connected.");
}

socket.onclose = function (event) {
  DB("websocket closed.");
}


socket.onmessage = function (event) {
  var msg = event.data;
  DB.post("onmsg",  msg.length);
  if (typeof msg == "string") { // String messages are just echoed to console.
    DB.post("str", msg);
  } else if (msg instanceof ArrayBuffer) {
    var dv = new DataView(msg);
    var cmd = dv.getUint8(0);
    var usr = dv.getUint8(1);
    switch (cmd)  {
    case 0:                      // My new user ID from the server.
      // Create my entity / turret object.
    case 1:                      // User moved and/or rotated.  If new user, create him.
      rem.d = dv.getFloat32(2);
      rem.x = dv.getFloat32(6);
      rem.y = dv.getFloat32(10);
      DB.post(`[mov ${dv.getUint8(1)}]`, `${rem.d.toFixed(2)} ${rem.x.toFixed(2)} ${rem.y.toFixed(2)}`);
      break
    }
  } else {
    DB(`[???] ${typeof msg} ${msg}`);
  }
}


/*
isNaN
typeof (blah)
9..constructor == Number
*/

</script></html>
<!---
  Debug_console_window
  Unit_testing_infrastructure
  Global_alises_and_functions
  Ticker_class
  Entity_class
  The_map
  The_models
  Face_object
  Group_object
  Vertex_transforms
  Matrix_library
  Main

  TODO:
   Concave Polygon
   {name:"cube",
    vertices:[[x,y,z],...],
    faces:[
-->
